/* automatically generated by rust-bindgen 0.70.1 */

pub const __has_safe_buffers: u32 = 1;
pub const __DARWIN_ONLY_64_BIT_INO_T: u32 = 1;
pub const __DARWIN_ONLY_UNIX_CONFORMANCE: u32 = 1;
pub const __DARWIN_ONLY_VERS_1050: u32 = 1;
pub const __DARWIN_UNIX03: u32 = 1;
pub const __DARWIN_64_BIT_INO_T: u32 = 1;
pub const __DARWIN_VERS_1050: u32 = 1;
pub const __DARWIN_NON_CANCELABLE: u32 = 0;
pub const __DARWIN_SUF_EXTSN: &[u8; 14] = b"$DARWIN_EXTSN\0";
pub const __DARWIN_C_ANSI: u32 = 4096;
pub const __DARWIN_C_FULL: u32 = 900000;
pub const __DARWIN_C_LEVEL: u32 = 900000;
pub const __STDC_WANT_LIB_EXT1__: u32 = 1;
pub const __DARWIN_NO_LONG_LONG: u32 = 0;
pub const _DARWIN_FEATURE_64_BIT_INODE: u32 = 1;
pub const _DARWIN_FEATURE_ONLY_64_BIT_INODE: u32 = 1;
pub const _DARWIN_FEATURE_ONLY_VERS_1050: u32 = 1;
pub const _DARWIN_FEATURE_ONLY_UNIX_CONFORMANCE: u32 = 1;
pub const _DARWIN_FEATURE_UNIX_CONFORMANCE: u32 = 3;
pub const __has_ptrcheck: u32 = 0;
pub const __PTHREAD_SIZE__: u32 = 8176;
pub const __PTHREAD_ATTR_SIZE__: u32 = 56;
pub const __PTHREAD_MUTEXATTR_SIZE__: u32 = 8;
pub const __PTHREAD_MUTEX_SIZE__: u32 = 56;
pub const __PTHREAD_CONDATTR_SIZE__: u32 = 8;
pub const __PTHREAD_COND_SIZE__: u32 = 40;
pub const __PTHREAD_ONCE_SIZE__: u32 = 8;
pub const __PTHREAD_RWLOCK_SIZE__: u32 = 192;
pub const __PTHREAD_RWLOCKATTR_SIZE__: u32 = 16;
pub const _QUAD_HIGHWORD: u32 = 1;
pub const _QUAD_LOWWORD: u32 = 0;
pub const __DARWIN_LITTLE_ENDIAN: u32 = 1234;
pub const __DARWIN_BIG_ENDIAN: u32 = 4321;
pub const __DARWIN_PDP_ENDIAN: u32 = 3412;
pub const __DARWIN_BYTE_ORDER: u32 = 1234;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const PDP_ENDIAN: u32 = 3412;
pub const BYTE_ORDER: u32 = 1234;
pub const __WORDSIZE: u32 = 64;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const INT64_MAX: u64 = 9223372036854775807;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT64_MIN: i64 = -9223372036854775808;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const UINT64_MAX: i32 = -1;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST64_MIN: i64 = -9223372036854775808;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const INT_LEAST64_MAX: u64 = 9223372036854775807;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const UINT_LEAST64_MAX: i32 = -1;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i32 = -32768;
pub const INT_FAST32_MIN: i32 = -2147483648;
pub const INT_FAST64_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u32 = 32767;
pub const INT_FAST32_MAX: u32 = 2147483647;
pub const INT_FAST64_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: u32 = 65535;
pub const UINT_FAST32_MAX: u32 = 4294967295;
pub const UINT_FAST64_MAX: i32 = -1;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const UINTPTR_MAX: i32 = -1;
pub const SIZE_MAX: i32 = -1;
pub const RSIZE_MAX: i32 = -1;
pub const WINT_MIN: i32 = -2147483648;
pub const WINT_MAX: u32 = 2147483647;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const __API_TO_BE_DEPRECATED: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_MACOS: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_IOS: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_MACCATALYST: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_WATCHOS: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_TVOS: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_DRIVERKIT: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_VISIONOS: u32 = 100000;
pub const __MAC_10_0: u32 = 1000;
pub const __MAC_10_1: u32 = 1010;
pub const __MAC_10_2: u32 = 1020;
pub const __MAC_10_3: u32 = 1030;
pub const __MAC_10_4: u32 = 1040;
pub const __MAC_10_5: u32 = 1050;
pub const __MAC_10_6: u32 = 1060;
pub const __MAC_10_7: u32 = 1070;
pub const __MAC_10_8: u32 = 1080;
pub const __MAC_10_9: u32 = 1090;
pub const __MAC_10_10: u32 = 101000;
pub const __MAC_10_10_2: u32 = 101002;
pub const __MAC_10_10_3: u32 = 101003;
pub const __MAC_10_11: u32 = 101100;
pub const __MAC_10_11_2: u32 = 101102;
pub const __MAC_10_11_3: u32 = 101103;
pub const __MAC_10_11_4: u32 = 101104;
pub const __MAC_10_12: u32 = 101200;
pub const __MAC_10_12_1: u32 = 101201;
pub const __MAC_10_12_2: u32 = 101202;
pub const __MAC_10_12_4: u32 = 101204;
pub const __MAC_10_13: u32 = 101300;
pub const __MAC_10_13_1: u32 = 101301;
pub const __MAC_10_13_2: u32 = 101302;
pub const __MAC_10_13_4: u32 = 101304;
pub const __MAC_10_14: u32 = 101400;
pub const __MAC_10_14_1: u32 = 101401;
pub const __MAC_10_14_4: u32 = 101404;
pub const __MAC_10_14_5: u32 = 101405;
pub const __MAC_10_14_6: u32 = 101406;
pub const __MAC_10_15: u32 = 101500;
pub const __MAC_10_15_1: u32 = 101501;
pub const __MAC_10_15_4: u32 = 101504;
pub const __MAC_10_16: u32 = 101600;
pub const __MAC_11_0: u32 = 110000;
pub const __MAC_11_1: u32 = 110100;
pub const __MAC_11_3: u32 = 110300;
pub const __MAC_11_4: u32 = 110400;
pub const __MAC_11_5: u32 = 110500;
pub const __MAC_11_6: u32 = 110600;
pub const __MAC_12_0: u32 = 120000;
pub const __MAC_12_1: u32 = 120100;
pub const __MAC_12_2: u32 = 120200;
pub const __MAC_12_3: u32 = 120300;
pub const __MAC_12_4: u32 = 120400;
pub const __MAC_12_5: u32 = 120500;
pub const __MAC_12_6: u32 = 120600;
pub const __MAC_12_7: u32 = 120700;
pub const __MAC_13_0: u32 = 130000;
pub const __MAC_13_1: u32 = 130100;
pub const __MAC_13_2: u32 = 130200;
pub const __MAC_13_3: u32 = 130300;
pub const __MAC_13_4: u32 = 130400;
pub const __MAC_13_5: u32 = 130500;
pub const __MAC_13_6: u32 = 130600;
pub const __MAC_14_0: u32 = 140000;
pub const __MAC_14_1: u32 = 140100;
pub const __MAC_14_2: u32 = 140200;
pub const __MAC_14_3: u32 = 140300;
pub const __MAC_14_4: u32 = 140400;
pub const __IPHONE_2_0: u32 = 20000;
pub const __IPHONE_2_1: u32 = 20100;
pub const __IPHONE_2_2: u32 = 20200;
pub const __IPHONE_3_0: u32 = 30000;
pub const __IPHONE_3_1: u32 = 30100;
pub const __IPHONE_3_2: u32 = 30200;
pub const __IPHONE_4_0: u32 = 40000;
pub const __IPHONE_4_1: u32 = 40100;
pub const __IPHONE_4_2: u32 = 40200;
pub const __IPHONE_4_3: u32 = 40300;
pub const __IPHONE_5_0: u32 = 50000;
pub const __IPHONE_5_1: u32 = 50100;
pub const __IPHONE_6_0: u32 = 60000;
pub const __IPHONE_6_1: u32 = 60100;
pub const __IPHONE_7_0: u32 = 70000;
pub const __IPHONE_7_1: u32 = 70100;
pub const __IPHONE_8_0: u32 = 80000;
pub const __IPHONE_8_1: u32 = 80100;
pub const __IPHONE_8_2: u32 = 80200;
pub const __IPHONE_8_3: u32 = 80300;
pub const __IPHONE_8_4: u32 = 80400;
pub const __IPHONE_9_0: u32 = 90000;
pub const __IPHONE_9_1: u32 = 90100;
pub const __IPHONE_9_2: u32 = 90200;
pub const __IPHONE_9_3: u32 = 90300;
pub const __IPHONE_10_0: u32 = 100000;
pub const __IPHONE_10_1: u32 = 100100;
pub const __IPHONE_10_2: u32 = 100200;
pub const __IPHONE_10_3: u32 = 100300;
pub const __IPHONE_11_0: u32 = 110000;
pub const __IPHONE_11_1: u32 = 110100;
pub const __IPHONE_11_2: u32 = 110200;
pub const __IPHONE_11_3: u32 = 110300;
pub const __IPHONE_11_4: u32 = 110400;
pub const __IPHONE_12_0: u32 = 120000;
pub const __IPHONE_12_1: u32 = 120100;
pub const __IPHONE_12_2: u32 = 120200;
pub const __IPHONE_12_3: u32 = 120300;
pub const __IPHONE_12_4: u32 = 120400;
pub const __IPHONE_13_0: u32 = 130000;
pub const __IPHONE_13_1: u32 = 130100;
pub const __IPHONE_13_2: u32 = 130200;
pub const __IPHONE_13_3: u32 = 130300;
pub const __IPHONE_13_4: u32 = 130400;
pub const __IPHONE_13_5: u32 = 130500;
pub const __IPHONE_13_6: u32 = 130600;
pub const __IPHONE_13_7: u32 = 130700;
pub const __IPHONE_14_0: u32 = 140000;
pub const __IPHONE_14_1: u32 = 140100;
pub const __IPHONE_14_2: u32 = 140200;
pub const __IPHONE_14_3: u32 = 140300;
pub const __IPHONE_14_5: u32 = 140500;
pub const __IPHONE_14_4: u32 = 140400;
pub const __IPHONE_14_6: u32 = 140600;
pub const __IPHONE_14_7: u32 = 140700;
pub const __IPHONE_14_8: u32 = 140800;
pub const __IPHONE_15_0: u32 = 150000;
pub const __IPHONE_15_1: u32 = 150100;
pub const __IPHONE_15_2: u32 = 150200;
pub const __IPHONE_15_3: u32 = 150300;
pub const __IPHONE_15_4: u32 = 150400;
pub const __IPHONE_15_5: u32 = 150500;
pub const __IPHONE_15_6: u32 = 150600;
pub const __IPHONE_15_7: u32 = 150700;
pub const __IPHONE_15_8: u32 = 150800;
pub const __IPHONE_16_0: u32 = 160000;
pub const __IPHONE_16_1: u32 = 160100;
pub const __IPHONE_16_2: u32 = 160200;
pub const __IPHONE_16_3: u32 = 160300;
pub const __IPHONE_16_4: u32 = 160400;
pub const __IPHONE_16_5: u32 = 160500;
pub const __IPHONE_16_6: u32 = 160600;
pub const __IPHONE_16_7: u32 = 160700;
pub const __IPHONE_17_0: u32 = 170000;
pub const __IPHONE_17_1: u32 = 170100;
pub const __IPHONE_17_2: u32 = 170200;
pub const __IPHONE_17_3: u32 = 170300;
pub const __IPHONE_17_4: u32 = 170400;
pub const __WATCHOS_1_0: u32 = 10000;
pub const __WATCHOS_2_0: u32 = 20000;
pub const __WATCHOS_2_1: u32 = 20100;
pub const __WATCHOS_2_2: u32 = 20200;
pub const __WATCHOS_3_0: u32 = 30000;
pub const __WATCHOS_3_1: u32 = 30100;
pub const __WATCHOS_3_1_1: u32 = 30101;
pub const __WATCHOS_3_2: u32 = 30200;
pub const __WATCHOS_4_0: u32 = 40000;
pub const __WATCHOS_4_1: u32 = 40100;
pub const __WATCHOS_4_2: u32 = 40200;
pub const __WATCHOS_4_3: u32 = 40300;
pub const __WATCHOS_5_0: u32 = 50000;
pub const __WATCHOS_5_1: u32 = 50100;
pub const __WATCHOS_5_2: u32 = 50200;
pub const __WATCHOS_5_3: u32 = 50300;
pub const __WATCHOS_6_0: u32 = 60000;
pub const __WATCHOS_6_1: u32 = 60100;
pub const __WATCHOS_6_2: u32 = 60200;
pub const __WATCHOS_7_0: u32 = 70000;
pub const __WATCHOS_7_1: u32 = 70100;
pub const __WATCHOS_7_2: u32 = 70200;
pub const __WATCHOS_7_3: u32 = 70300;
pub const __WATCHOS_7_4: u32 = 70400;
pub const __WATCHOS_7_5: u32 = 70500;
pub const __WATCHOS_7_6: u32 = 70600;
pub const __WATCHOS_8_0: u32 = 80000;
pub const __WATCHOS_8_1: u32 = 80100;
pub const __WATCHOS_8_3: u32 = 80300;
pub const __WATCHOS_8_4: u32 = 80400;
pub const __WATCHOS_8_5: u32 = 80500;
pub const __WATCHOS_8_6: u32 = 80600;
pub const __WATCHOS_8_7: u32 = 80700;
pub const __WATCHOS_8_8: u32 = 80800;
pub const __WATCHOS_9_0: u32 = 90000;
pub const __WATCHOS_9_1: u32 = 90100;
pub const __WATCHOS_9_2: u32 = 90200;
pub const __WATCHOS_9_3: u32 = 90300;
pub const __WATCHOS_9_4: u32 = 90400;
pub const __WATCHOS_9_5: u32 = 90500;
pub const __WATCHOS_9_6: u32 = 90600;
pub const __WATCHOS_10_0: u32 = 100000;
pub const __WATCHOS_10_1: u32 = 100100;
pub const __WATCHOS_10_2: u32 = 100200;
pub const __WATCHOS_10_3: u32 = 100300;
pub const __WATCHOS_10_4: u32 = 100400;
pub const __TVOS_9_0: u32 = 90000;
pub const __TVOS_9_1: u32 = 90100;
pub const __TVOS_9_2: u32 = 90200;
pub const __TVOS_10_0: u32 = 100000;
pub const __TVOS_10_0_1: u32 = 100001;
pub const __TVOS_10_1: u32 = 100100;
pub const __TVOS_10_2: u32 = 100200;
pub const __TVOS_11_0: u32 = 110000;
pub const __TVOS_11_1: u32 = 110100;
pub const __TVOS_11_2: u32 = 110200;
pub const __TVOS_11_3: u32 = 110300;
pub const __TVOS_11_4: u32 = 110400;
pub const __TVOS_12_0: u32 = 120000;
pub const __TVOS_12_1: u32 = 120100;
pub const __TVOS_12_2: u32 = 120200;
pub const __TVOS_12_3: u32 = 120300;
pub const __TVOS_12_4: u32 = 120400;
pub const __TVOS_13_0: u32 = 130000;
pub const __TVOS_13_2: u32 = 130200;
pub const __TVOS_13_3: u32 = 130300;
pub const __TVOS_13_4: u32 = 130400;
pub const __TVOS_14_0: u32 = 140000;
pub const __TVOS_14_1: u32 = 140100;
pub const __TVOS_14_2: u32 = 140200;
pub const __TVOS_14_3: u32 = 140300;
pub const __TVOS_14_5: u32 = 140500;
pub const __TVOS_14_6: u32 = 140600;
pub const __TVOS_14_7: u32 = 140700;
pub const __TVOS_15_0: u32 = 150000;
pub const __TVOS_15_1: u32 = 150100;
pub const __TVOS_15_2: u32 = 150200;
pub const __TVOS_15_3: u32 = 150300;
pub const __TVOS_15_4: u32 = 150400;
pub const __TVOS_15_5: u32 = 150500;
pub const __TVOS_15_6: u32 = 150600;
pub const __TVOS_16_0: u32 = 160000;
pub const __TVOS_16_1: u32 = 160100;
pub const __TVOS_16_2: u32 = 160200;
pub const __TVOS_16_3: u32 = 160300;
pub const __TVOS_16_4: u32 = 160400;
pub const __TVOS_16_5: u32 = 160500;
pub const __TVOS_16_6: u32 = 160600;
pub const __TVOS_17_0: u32 = 170000;
pub const __TVOS_17_1: u32 = 170100;
pub const __TVOS_17_2: u32 = 170200;
pub const __TVOS_17_3: u32 = 170300;
pub const __TVOS_17_4: u32 = 170400;
pub const __BRIDGEOS_2_0: u32 = 20000;
pub const __BRIDGEOS_3_0: u32 = 30000;
pub const __BRIDGEOS_3_1: u32 = 30100;
pub const __BRIDGEOS_3_4: u32 = 30400;
pub const __BRIDGEOS_4_0: u32 = 40000;
pub const __BRIDGEOS_4_1: u32 = 40100;
pub const __BRIDGEOS_5_0: u32 = 50000;
pub const __BRIDGEOS_5_1: u32 = 50100;
pub const __BRIDGEOS_5_3: u32 = 50300;
pub const __BRIDGEOS_6_0: u32 = 60000;
pub const __BRIDGEOS_6_2: u32 = 60200;
pub const __BRIDGEOS_6_4: u32 = 60400;
pub const __BRIDGEOS_6_5: u32 = 60500;
pub const __BRIDGEOS_6_6: u32 = 60600;
pub const __BRIDGEOS_7_0: u32 = 70000;
pub const __BRIDGEOS_7_1: u32 = 70100;
pub const __BRIDGEOS_7_2: u32 = 70200;
pub const __BRIDGEOS_7_3: u32 = 70300;
pub const __BRIDGEOS_7_4: u32 = 70400;
pub const __BRIDGEOS_7_6: u32 = 70600;
pub const __BRIDGEOS_8_0: u32 = 80000;
pub const __BRIDGEOS_8_1: u32 = 80100;
pub const __BRIDGEOS_8_2: u32 = 80200;
pub const __BRIDGEOS_8_3: u32 = 80300;
pub const __BRIDGEOS_8_4: u32 = 80400;
pub const __DRIVERKIT_19_0: u32 = 190000;
pub const __DRIVERKIT_20_0: u32 = 200000;
pub const __DRIVERKIT_21_0: u32 = 210000;
pub const __DRIVERKIT_22_0: u32 = 220000;
pub const __DRIVERKIT_22_4: u32 = 220400;
pub const __DRIVERKIT_22_5: u32 = 220500;
pub const __DRIVERKIT_22_6: u32 = 220600;
pub const __DRIVERKIT_23_0: u32 = 230000;
pub const __DRIVERKIT_23_1: u32 = 230100;
pub const __DRIVERKIT_23_2: u32 = 230200;
pub const __DRIVERKIT_23_3: u32 = 230300;
pub const __DRIVERKIT_23_4: u32 = 230400;
pub const __VISIONOS_1_0: u32 = 10000;
pub const __VISIONOS_1_1: u32 = 10100;
pub const MAC_OS_X_VERSION_10_0: u32 = 1000;
pub const MAC_OS_X_VERSION_10_1: u32 = 1010;
pub const MAC_OS_X_VERSION_10_2: u32 = 1020;
pub const MAC_OS_X_VERSION_10_3: u32 = 1030;
pub const MAC_OS_X_VERSION_10_4: u32 = 1040;
pub const MAC_OS_X_VERSION_10_5: u32 = 1050;
pub const MAC_OS_X_VERSION_10_6: u32 = 1060;
pub const MAC_OS_X_VERSION_10_7: u32 = 1070;
pub const MAC_OS_X_VERSION_10_8: u32 = 1080;
pub const MAC_OS_X_VERSION_10_9: u32 = 1090;
pub const MAC_OS_X_VERSION_10_10: u32 = 101000;
pub const MAC_OS_X_VERSION_10_10_2: u32 = 101002;
pub const MAC_OS_X_VERSION_10_10_3: u32 = 101003;
pub const MAC_OS_X_VERSION_10_11: u32 = 101100;
pub const MAC_OS_X_VERSION_10_11_2: u32 = 101102;
pub const MAC_OS_X_VERSION_10_11_3: u32 = 101103;
pub const MAC_OS_X_VERSION_10_11_4: u32 = 101104;
pub const MAC_OS_X_VERSION_10_12: u32 = 101200;
pub const MAC_OS_X_VERSION_10_12_1: u32 = 101201;
pub const MAC_OS_X_VERSION_10_12_2: u32 = 101202;
pub const MAC_OS_X_VERSION_10_12_4: u32 = 101204;
pub const MAC_OS_X_VERSION_10_13: u32 = 101300;
pub const MAC_OS_X_VERSION_10_13_1: u32 = 101301;
pub const MAC_OS_X_VERSION_10_13_2: u32 = 101302;
pub const MAC_OS_X_VERSION_10_13_4: u32 = 101304;
pub const MAC_OS_X_VERSION_10_14: u32 = 101400;
pub const MAC_OS_X_VERSION_10_14_1: u32 = 101401;
pub const MAC_OS_X_VERSION_10_14_4: u32 = 101404;
pub const MAC_OS_X_VERSION_10_14_5: u32 = 101405;
pub const MAC_OS_X_VERSION_10_14_6: u32 = 101406;
pub const MAC_OS_X_VERSION_10_15: u32 = 101500;
pub const MAC_OS_X_VERSION_10_15_1: u32 = 101501;
pub const MAC_OS_X_VERSION_10_15_4: u32 = 101504;
pub const MAC_OS_X_VERSION_10_16: u32 = 101600;
pub const MAC_OS_VERSION_11_0: u32 = 110000;
pub const MAC_OS_VERSION_11_1: u32 = 110100;
pub const MAC_OS_VERSION_11_3: u32 = 110300;
pub const MAC_OS_VERSION_11_4: u32 = 110400;
pub const MAC_OS_VERSION_11_5: u32 = 110500;
pub const MAC_OS_VERSION_11_6: u32 = 110600;
pub const MAC_OS_VERSION_12_0: u32 = 120000;
pub const MAC_OS_VERSION_12_1: u32 = 120100;
pub const MAC_OS_VERSION_12_2: u32 = 120200;
pub const MAC_OS_VERSION_12_3: u32 = 120300;
pub const MAC_OS_VERSION_12_4: u32 = 120400;
pub const MAC_OS_VERSION_12_5: u32 = 120500;
pub const MAC_OS_VERSION_12_6: u32 = 120600;
pub const MAC_OS_VERSION_12_7: u32 = 120700;
pub const MAC_OS_VERSION_13_0: u32 = 130000;
pub const MAC_OS_VERSION_13_1: u32 = 130100;
pub const MAC_OS_VERSION_13_2: u32 = 130200;
pub const MAC_OS_VERSION_13_3: u32 = 130300;
pub const MAC_OS_VERSION_13_4: u32 = 130400;
pub const MAC_OS_VERSION_13_5: u32 = 130500;
pub const MAC_OS_VERSION_13_6: u32 = 130600;
pub const MAC_OS_VERSION_14_0: u32 = 140000;
pub const MAC_OS_VERSION_14_1: u32 = 140100;
pub const MAC_OS_VERSION_14_2: u32 = 140200;
pub const MAC_OS_VERSION_14_3: u32 = 140300;
pub const MAC_OS_VERSION_14_4: u32 = 140400;
pub const __MAC_OS_X_VERSION_MAX_ALLOWED: u32 = 140400;
pub const __ENABLE_LEGACY_MAC_AVAILABILITY: u32 = 1;
pub const __DARWIN_FD_SETSIZE: u32 = 1024;
pub const __DARWIN_NBBY: u32 = 8;
pub const NBBY: u32 = 8;
pub const FD_SETSIZE: u32 = 1024;
pub const __PRI_8_LENGTH_MODIFIER__: &[u8; 3] = b"hh\0";
pub const __PRI_64_LENGTH_MODIFIER__: &[u8; 3] = b"ll\0";
pub const __SCN_64_LENGTH_MODIFIER__: &[u8; 3] = b"ll\0";
pub const __PRI_MAX_LENGTH_MODIFIER__: &[u8; 2] = b"j\0";
pub const __SCN_MAX_LENGTH_MODIFIER__: &[u8; 2] = b"j\0";
pub const PRId8: &[u8; 4] = b"hhd\0";
pub const PRIi8: &[u8; 4] = b"hhi\0";
pub const PRIo8: &[u8; 4] = b"hho\0";
pub const PRIu8: &[u8; 4] = b"hhu\0";
pub const PRIx8: &[u8; 4] = b"hhx\0";
pub const PRIX8: &[u8; 4] = b"hhX\0";
pub const PRId16: &[u8; 3] = b"hd\0";
pub const PRIi16: &[u8; 3] = b"hi\0";
pub const PRIo16: &[u8; 3] = b"ho\0";
pub const PRIu16: &[u8; 3] = b"hu\0";
pub const PRIx16: &[u8; 3] = b"hx\0";
pub const PRIX16: &[u8; 3] = b"hX\0";
pub const PRId32: &[u8; 2] = b"d\0";
pub const PRIi32: &[u8; 2] = b"i\0";
pub const PRIo32: &[u8; 2] = b"o\0";
pub const PRIu32: &[u8; 2] = b"u\0";
pub const PRIx32: &[u8; 2] = b"x\0";
pub const PRIX32: &[u8; 2] = b"X\0";
pub const PRId64: &[u8; 4] = b"lld\0";
pub const PRIi64: &[u8; 4] = b"lli\0";
pub const PRIo64: &[u8; 4] = b"llo\0";
pub const PRIu64: &[u8; 4] = b"llu\0";
pub const PRIx64: &[u8; 4] = b"llx\0";
pub const PRIX64: &[u8; 4] = b"llX\0";
pub const PRIdLEAST8: &[u8; 4] = b"hhd\0";
pub const PRIiLEAST8: &[u8; 4] = b"hhi\0";
pub const PRIoLEAST8: &[u8; 4] = b"hho\0";
pub const PRIuLEAST8: &[u8; 4] = b"hhu\0";
pub const PRIxLEAST8: &[u8; 4] = b"hhx\0";
pub const PRIXLEAST8: &[u8; 4] = b"hhX\0";
pub const PRIdLEAST16: &[u8; 3] = b"hd\0";
pub const PRIiLEAST16: &[u8; 3] = b"hi\0";
pub const PRIoLEAST16: &[u8; 3] = b"ho\0";
pub const PRIuLEAST16: &[u8; 3] = b"hu\0";
pub const PRIxLEAST16: &[u8; 3] = b"hx\0";
pub const PRIXLEAST16: &[u8; 3] = b"hX\0";
pub const PRIdLEAST32: &[u8; 2] = b"d\0";
pub const PRIiLEAST32: &[u8; 2] = b"i\0";
pub const PRIoLEAST32: &[u8; 2] = b"o\0";
pub const PRIuLEAST32: &[u8; 2] = b"u\0";
pub const PRIxLEAST32: &[u8; 2] = b"x\0";
pub const PRIXLEAST32: &[u8; 2] = b"X\0";
pub const PRIdLEAST64: &[u8; 4] = b"lld\0";
pub const PRIiLEAST64: &[u8; 4] = b"lli\0";
pub const PRIoLEAST64: &[u8; 4] = b"llo\0";
pub const PRIuLEAST64: &[u8; 4] = b"llu\0";
pub const PRIxLEAST64: &[u8; 4] = b"llx\0";
pub const PRIXLEAST64: &[u8; 4] = b"llX\0";
pub const PRIdFAST8: &[u8; 4] = b"hhd\0";
pub const PRIiFAST8: &[u8; 4] = b"hhi\0";
pub const PRIoFAST8: &[u8; 4] = b"hho\0";
pub const PRIuFAST8: &[u8; 4] = b"hhu\0";
pub const PRIxFAST8: &[u8; 4] = b"hhx\0";
pub const PRIXFAST8: &[u8; 4] = b"hhX\0";
pub const PRIdFAST16: &[u8; 3] = b"hd\0";
pub const PRIiFAST16: &[u8; 3] = b"hi\0";
pub const PRIoFAST16: &[u8; 3] = b"ho\0";
pub const PRIuFAST16: &[u8; 3] = b"hu\0";
pub const PRIxFAST16: &[u8; 3] = b"hx\0";
pub const PRIXFAST16: &[u8; 3] = b"hX\0";
pub const PRIdFAST32: &[u8; 2] = b"d\0";
pub const PRIiFAST32: &[u8; 2] = b"i\0";
pub const PRIoFAST32: &[u8; 2] = b"o\0";
pub const PRIuFAST32: &[u8; 2] = b"u\0";
pub const PRIxFAST32: &[u8; 2] = b"x\0";
pub const PRIXFAST32: &[u8; 2] = b"X\0";
pub const PRIdFAST64: &[u8; 4] = b"lld\0";
pub const PRIiFAST64: &[u8; 4] = b"lli\0";
pub const PRIoFAST64: &[u8; 4] = b"llo\0";
pub const PRIuFAST64: &[u8; 4] = b"llu\0";
pub const PRIxFAST64: &[u8; 4] = b"llx\0";
pub const PRIXFAST64: &[u8; 4] = b"llX\0";
pub const PRIdPTR: &[u8; 3] = b"ld\0";
pub const PRIiPTR: &[u8; 3] = b"li\0";
pub const PRIoPTR: &[u8; 3] = b"lo\0";
pub const PRIuPTR: &[u8; 3] = b"lu\0";
pub const PRIxPTR: &[u8; 3] = b"lx\0";
pub const PRIXPTR: &[u8; 3] = b"lX\0";
pub const PRIdMAX: &[u8; 3] = b"jd\0";
pub const PRIiMAX: &[u8; 3] = b"ji\0";
pub const PRIoMAX: &[u8; 3] = b"jo\0";
pub const PRIuMAX: &[u8; 3] = b"ju\0";
pub const PRIxMAX: &[u8; 3] = b"jx\0";
pub const PRIXMAX: &[u8; 3] = b"jX\0";
pub const SCNd8: &[u8; 4] = b"hhd\0";
pub const SCNi8: &[u8; 4] = b"hhi\0";
pub const SCNo8: &[u8; 4] = b"hho\0";
pub const SCNu8: &[u8; 4] = b"hhu\0";
pub const SCNx8: &[u8; 4] = b"hhx\0";
pub const SCNd16: &[u8; 3] = b"hd\0";
pub const SCNi16: &[u8; 3] = b"hi\0";
pub const SCNo16: &[u8; 3] = b"ho\0";
pub const SCNu16: &[u8; 3] = b"hu\0";
pub const SCNx16: &[u8; 3] = b"hx\0";
pub const SCNd32: &[u8; 2] = b"d\0";
pub const SCNi32: &[u8; 2] = b"i\0";
pub const SCNo32: &[u8; 2] = b"o\0";
pub const SCNu32: &[u8; 2] = b"u\0";
pub const SCNx32: &[u8; 2] = b"x\0";
pub const SCNd64: &[u8; 4] = b"lld\0";
pub const SCNi64: &[u8; 4] = b"lli\0";
pub const SCNo64: &[u8; 4] = b"llo\0";
pub const SCNu64: &[u8; 4] = b"llu\0";
pub const SCNx64: &[u8; 4] = b"llx\0";
pub const SCNdLEAST8: &[u8; 4] = b"hhd\0";
pub const SCNiLEAST8: &[u8; 4] = b"hhi\0";
pub const SCNoLEAST8: &[u8; 4] = b"hho\0";
pub const SCNuLEAST8: &[u8; 4] = b"hhu\0";
pub const SCNxLEAST8: &[u8; 4] = b"hhx\0";
pub const SCNdLEAST16: &[u8; 3] = b"hd\0";
pub const SCNiLEAST16: &[u8; 3] = b"hi\0";
pub const SCNoLEAST16: &[u8; 3] = b"ho\0";
pub const SCNuLEAST16: &[u8; 3] = b"hu\0";
pub const SCNxLEAST16: &[u8; 3] = b"hx\0";
pub const SCNdLEAST32: &[u8; 2] = b"d\0";
pub const SCNiLEAST32: &[u8; 2] = b"i\0";
pub const SCNoLEAST32: &[u8; 2] = b"o\0";
pub const SCNuLEAST32: &[u8; 2] = b"u\0";
pub const SCNxLEAST32: &[u8; 2] = b"x\0";
pub const SCNdLEAST64: &[u8; 4] = b"lld\0";
pub const SCNiLEAST64: &[u8; 4] = b"lli\0";
pub const SCNoLEAST64: &[u8; 4] = b"llo\0";
pub const SCNuLEAST64: &[u8; 4] = b"llu\0";
pub const SCNxLEAST64: &[u8; 4] = b"llx\0";
pub const SCNdFAST8: &[u8; 4] = b"hhd\0";
pub const SCNiFAST8: &[u8; 4] = b"hhi\0";
pub const SCNoFAST8: &[u8; 4] = b"hho\0";
pub const SCNuFAST8: &[u8; 4] = b"hhu\0";
pub const SCNxFAST8: &[u8; 4] = b"hhx\0";
pub const SCNdFAST16: &[u8; 3] = b"hd\0";
pub const SCNiFAST16: &[u8; 3] = b"hi\0";
pub const SCNoFAST16: &[u8; 3] = b"ho\0";
pub const SCNuFAST16: &[u8; 3] = b"hu\0";
pub const SCNxFAST16: &[u8; 3] = b"hx\0";
pub const SCNdFAST32: &[u8; 2] = b"d\0";
pub const SCNiFAST32: &[u8; 2] = b"i\0";
pub const SCNoFAST32: &[u8; 2] = b"o\0";
pub const SCNuFAST32: &[u8; 2] = b"u\0";
pub const SCNxFAST32: &[u8; 2] = b"x\0";
pub const SCNdFAST64: &[u8; 4] = b"lld\0";
pub const SCNiFAST64: &[u8; 4] = b"lli\0";
pub const SCNoFAST64: &[u8; 4] = b"llo\0";
pub const SCNuFAST64: &[u8; 4] = b"llu\0";
pub const SCNxFAST64: &[u8; 4] = b"llx\0";
pub const SCNdPTR: &[u8; 3] = b"ld\0";
pub const SCNiPTR: &[u8; 3] = b"li\0";
pub const SCNoPTR: &[u8; 3] = b"lo\0";
pub const SCNuPTR: &[u8; 3] = b"lu\0";
pub const SCNxPTR: &[u8; 3] = b"lx\0";
pub const SCNdMAX: &[u8; 3] = b"jd\0";
pub const SCNiMAX: &[u8; 3] = b"ji\0";
pub const SCNoMAX: &[u8; 3] = b"jo\0";
pub const SCNuMAX: &[u8; 3] = b"ju\0";
pub const SCNxMAX: &[u8; 3] = b"jx\0";
pub const __DARWIN_WCHAR_MIN: i32 = -2147483648;
pub const _FORTIFY_SOURCE: u32 = 2;
pub const __DARWIN_CLK_TCK: u32 = 100;
pub const MB_LEN_MAX: u32 = 6;
pub const CLK_TCK: u32 = 100;
pub const CHAR_BIT: u32 = 8;
pub const SCHAR_MAX: u32 = 127;
pub const SCHAR_MIN: i32 = -128;
pub const UCHAR_MAX: u32 = 255;
pub const CHAR_MAX: u32 = 127;
pub const CHAR_MIN: i32 = -128;
pub const USHRT_MAX: u32 = 65535;
pub const SHRT_MAX: u32 = 32767;
pub const SHRT_MIN: i32 = -32768;
pub const UINT_MAX: u32 = 4294967295;
pub const INT_MAX: u32 = 2147483647;
pub const INT_MIN: i32 = -2147483648;
pub const ULONG_MAX: i32 = -1;
pub const LONG_MAX: u64 = 9223372036854775807;
pub const LONG_MIN: i64 = -9223372036854775808;
pub const ULLONG_MAX: i32 = -1;
pub const LLONG_MAX: u64 = 9223372036854775807;
pub const LLONG_MIN: i64 = -9223372036854775808;
pub const LONG_BIT: u32 = 64;
pub const SSIZE_MAX: u64 = 9223372036854775807;
pub const WORD_BIT: u32 = 32;
pub const SIZE_T_MAX: i32 = -1;
pub const UQUAD_MAX: i32 = -1;
pub const QUAD_MAX: u64 = 9223372036854775807;
pub const QUAD_MIN: i64 = -9223372036854775808;
pub const ARG_MAX: u32 = 1048576;
pub const CHILD_MAX: u32 = 266;
pub const GID_MAX: u32 = 2147483647;
pub const LINK_MAX: u32 = 32767;
pub const MAX_CANON: u32 = 1024;
pub const MAX_INPUT: u32 = 1024;
pub const NAME_MAX: u32 = 255;
pub const NGROUPS_MAX: u32 = 16;
pub const UID_MAX: u32 = 2147483647;
pub const OPEN_MAX: u32 = 10240;
pub const PATH_MAX: u32 = 1024;
pub const PIPE_BUF: u32 = 512;
pub const BC_BASE_MAX: u32 = 99;
pub const BC_DIM_MAX: u32 = 2048;
pub const BC_SCALE_MAX: u32 = 99;
pub const BC_STRING_MAX: u32 = 1000;
pub const CHARCLASS_NAME_MAX: u32 = 14;
pub const COLL_WEIGHTS_MAX: u32 = 2;
pub const EQUIV_CLASS_MAX: u32 = 2;
pub const EXPR_NEST_MAX: u32 = 32;
pub const LINE_MAX: u32 = 2048;
pub const RE_DUP_MAX: u32 = 255;
pub const NZERO: u32 = 20;
pub const _POSIX_ARG_MAX: u32 = 4096;
pub const _POSIX_CHILD_MAX: u32 = 25;
pub const _POSIX_LINK_MAX: u32 = 8;
pub const _POSIX_MAX_CANON: u32 = 255;
pub const _POSIX_MAX_INPUT: u32 = 255;
pub const _POSIX_NAME_MAX: u32 = 14;
pub const _POSIX_NGROUPS_MAX: u32 = 8;
pub const _POSIX_OPEN_MAX: u32 = 20;
pub const _POSIX_PATH_MAX: u32 = 256;
pub const _POSIX_PIPE_BUF: u32 = 512;
pub const _POSIX_SSIZE_MAX: u32 = 32767;
pub const _POSIX_STREAM_MAX: u32 = 8;
pub const _POSIX_TZNAME_MAX: u32 = 6;
pub const _POSIX2_BC_BASE_MAX: u32 = 99;
pub const _POSIX2_BC_DIM_MAX: u32 = 2048;
pub const _POSIX2_BC_SCALE_MAX: u32 = 99;
pub const _POSIX2_BC_STRING_MAX: u32 = 1000;
pub const _POSIX2_EQUIV_CLASS_MAX: u32 = 2;
pub const _POSIX2_EXPR_NEST_MAX: u32 = 32;
pub const _POSIX2_LINE_MAX: u32 = 2048;
pub const _POSIX2_RE_DUP_MAX: u32 = 255;
pub const _POSIX_AIO_LISTIO_MAX: u32 = 2;
pub const _POSIX_AIO_MAX: u32 = 1;
pub const _POSIX_DELAYTIMER_MAX: u32 = 32;
pub const _POSIX_MQ_OPEN_MAX: u32 = 8;
pub const _POSIX_MQ_PRIO_MAX: u32 = 32;
pub const _POSIX_RTSIG_MAX: u32 = 8;
pub const _POSIX_SEM_NSEMS_MAX: u32 = 256;
pub const _POSIX_SEM_VALUE_MAX: u32 = 32767;
pub const _POSIX_SIGQUEUE_MAX: u32 = 32;
pub const _POSIX_TIMER_MAX: u32 = 32;
pub const _POSIX_CLOCKRES_MIN: u32 = 20000000;
pub const _POSIX_THREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const _POSIX_THREAD_KEYS_MAX: u32 = 128;
pub const _POSIX_THREAD_THREADS_MAX: u32 = 64;
pub const PTHREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const PTHREAD_KEYS_MAX: u32 = 512;
pub const PTHREAD_STACK_MIN: u32 = 16384;
pub const _POSIX_HOST_NAME_MAX: u32 = 255;
pub const _POSIX_LOGIN_NAME_MAX: u32 = 9;
pub const _POSIX_SS_REPL_MAX: u32 = 4;
pub const _POSIX_SYMLINK_MAX: u32 = 255;
pub const _POSIX_SYMLOOP_MAX: u32 = 8;
pub const _POSIX_TRACE_EVENT_NAME_MAX: u32 = 30;
pub const _POSIX_TRACE_NAME_MAX: u32 = 8;
pub const _POSIX_TRACE_SYS_MAX: u32 = 8;
pub const _POSIX_TRACE_USER_EVENT_MAX: u32 = 32;
pub const _POSIX_TTY_NAME_MAX: u32 = 9;
pub const _POSIX2_CHARCLASS_NAME_MAX: u32 = 14;
pub const _POSIX2_COLL_WEIGHTS_MAX: u32 = 2;
pub const _POSIX_RE_DUP_MAX: u32 = 255;
pub const OFF_MIN: i64 = -9223372036854775808;
pub const OFF_MAX: u64 = 9223372036854775807;
pub const PASS_MAX: u32 = 128;
pub const NL_ARGMAX: u32 = 9;
pub const NL_LANGMAX: u32 = 14;
pub const NL_MSGMAX: u32 = 32767;
pub const NL_NMAX: u32 = 1;
pub const NL_SETMAX: u32 = 255;
pub const NL_TEXTMAX: u32 = 2048;
pub const _XOPEN_IOV_MAX: u32 = 16;
pub const IOV_MAX: u32 = 1024;
pub const _XOPEN_NAME_MAX: u32 = 255;
pub const _XOPEN_PATH_MAX: u32 = 1024;
pub const MDB_FMT_Z: &[u8; 2] = b"z\0";
pub const MDB_SIZE_MAX: i32 = -1;
pub const MDB_VERSION_MAJOR: u32 = 0;
pub const MDB_VERSION_MINOR: u32 = 9;
pub const MDB_VERSION_PATCH: u32 = 70;
pub const MDB_VERSION_DATE: &[u8; 18] = b"December 19, 2015\0";
pub const MDB_FIXEDMAP: u32 = 1;
pub const MDB_NOSUBDIR: u32 = 16384;
pub const MDB_NOSYNC: u32 = 65536;
pub const MDB_RDONLY: u32 = 131072;
pub const MDB_NOMETASYNC: u32 = 262144;
pub const MDB_WRITEMAP: u32 = 524288;
pub const MDB_MAPASYNC: u32 = 1048576;
pub const MDB_NOTLS: u32 = 2097152;
pub const MDB_NOLOCK: u32 = 4194304;
pub const MDB_NORDAHEAD: u32 = 8388608;
pub const MDB_NOMEMINIT: u32 = 16777216;
pub const MDB_PREVSNAPSHOT: u32 = 33554432;
pub const MDB_REVERSEKEY: u32 = 2;
pub const MDB_DUPSORT: u32 = 4;
pub const MDB_INTEGERKEY: u32 = 8;
pub const MDB_DUPFIXED: u32 = 16;
pub const MDB_INTEGERDUP: u32 = 32;
pub const MDB_REVERSEDUP: u32 = 64;
pub const MDB_CREATE: u32 = 262144;
pub const MDB_NOOVERWRITE: u32 = 16;
pub const MDB_NODUPDATA: u32 = 32;
pub const MDB_CURRENT: u32 = 64;
pub const MDB_RESERVE: u32 = 65536;
pub const MDB_APPEND: u32 = 131072;
pub const MDB_APPENDDUP: u32 = 262144;
pub const MDB_MULTIPLE: u32 = 524288;
pub const MDB_CP_COMPACT: u32 = 1;
pub const MDB_SUCCESS: u32 = 0;
pub const MDB_KEYEXIST: i32 = -30799;
pub const MDB_NOTFOUND: i32 = -30798;
pub const MDB_PAGE_NOTFOUND: i32 = -30797;
pub const MDB_CORRUPTED: i32 = -30796;
pub const MDB_PANIC: i32 = -30795;
pub const MDB_VERSION_MISMATCH: i32 = -30794;
pub const MDB_INVALID: i32 = -30793;
pub const MDB_MAP_FULL: i32 = -30792;
pub const MDB_DBS_FULL: i32 = -30791;
pub const MDB_READERS_FULL: i32 = -30790;
pub const MDB_TLS_FULL: i32 = -30789;
pub const MDB_TXN_FULL: i32 = -30788;
pub const MDB_CURSOR_FULL: i32 = -30787;
pub const MDB_PAGE_FULL: i32 = -30786;
pub const MDB_MAP_RESIZED: i32 = -30785;
pub const MDB_INCOMPATIBLE: i32 = -30784;
pub const MDB_BAD_RSLOT: i32 = -30783;
pub const MDB_BAD_TXN: i32 = -30782;
pub const MDB_BAD_VALSIZE: i32 = -30781;
pub const MDB_BAD_DBI: i32 = -30780;
pub const MDB_PROBLEM: i32 = -30779;
pub const MDB_LAST_ERRCODE: i32 = -30779;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_longlong;
pub type __uint64_t = ::std::os::raw::c_ulonglong;
pub type __darwin_intptr_t = ::std::os::raw::c_long;
pub type __darwin_natural_t = ::std::os::raw::c_uint;
pub type __darwin_ct_rune_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t {
    pub __mbstate8: [::std::os::raw::c_char; 128usize],
    pub _mbstateL: ::std::os::raw::c_longlong,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __mbstate_t"][::std::mem::size_of::<__mbstate_t>() - 128usize];
    ["Alignment of __mbstate_t"][::std::mem::align_of::<__mbstate_t>() - 8usize];
    ["Offset of field: __mbstate_t::__mbstate8"]
        [::std::mem::offset_of!(__mbstate_t, __mbstate8) - 0usize];
    ["Offset of field: __mbstate_t::_mbstateL"]
        [::std::mem::offset_of!(__mbstate_t, _mbstateL) - 0usize];
};
pub type __darwin_mbstate_t = __mbstate_t;
pub type __darwin_ptrdiff_t = ::std::os::raw::c_long;
pub type __darwin_size_t = ::std::os::raw::c_ulong;
pub type __darwin_va_list = __builtin_va_list;
pub type __darwin_wchar_t = ::std::os::raw::c_int;
pub type __darwin_rune_t = __darwin_wchar_t;
pub type __darwin_wint_t = ::std::os::raw::c_int;
pub type __darwin_clock_t = ::std::os::raw::c_ulong;
pub type __darwin_socklen_t = __uint32_t;
pub type __darwin_ssize_t = ::std::os::raw::c_long;
pub type __darwin_time_t = ::std::os::raw::c_long;
pub type u_int8_t = ::std::os::raw::c_uchar;
pub type u_int16_t = ::std::os::raw::c_ushort;
pub type u_int32_t = ::std::os::raw::c_uint;
pub type u_int64_t = ::std::os::raw::c_ulonglong;
pub type register_t = i64;
pub type user_addr_t = u_int64_t;
pub type user_size_t = u_int64_t;
pub type user_ssize_t = i64;
pub type user_long_t = i64;
pub type user_ulong_t = u_int64_t;
pub type user_time_t = i64;
pub type user_off_t = i64;
pub type syscall_arg_t = u_int64_t;
pub type __darwin_blkcnt_t = __int64_t;
pub type __darwin_blksize_t = __int32_t;
pub type __darwin_dev_t = __int32_t;
pub type __darwin_fsblkcnt_t = ::std::os::raw::c_uint;
pub type __darwin_fsfilcnt_t = ::std::os::raw::c_uint;
pub type __darwin_gid_t = __uint32_t;
pub type __darwin_id_t = __uint32_t;
pub type __darwin_ino64_t = __uint64_t;
pub type __darwin_ino_t = __darwin_ino64_t;
pub type __darwin_mach_port_name_t = __darwin_natural_t;
pub type __darwin_mach_port_t = __darwin_mach_port_name_t;
pub type __darwin_mode_t = __uint16_t;
pub type __darwin_off_t = __int64_t;
pub type __darwin_pid_t = __int32_t;
pub type __darwin_sigset_t = __uint32_t;
pub type __darwin_suseconds_t = __int32_t;
pub type __darwin_uid_t = __uint32_t;
pub type __darwin_useconds_t = __uint32_t;
pub type __darwin_uuid_t = [::std::os::raw::c_uchar; 16usize];
pub type __darwin_uuid_string_t = [::std::os::raw::c_char; 37usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_pthread_handler_rec {
    pub __routine: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    pub __arg: *mut ::std::os::raw::c_void,
    pub __next: *mut __darwin_pthread_handler_rec,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __darwin_pthread_handler_rec"]
        [::std::mem::size_of::<__darwin_pthread_handler_rec>() - 24usize];
    ["Alignment of __darwin_pthread_handler_rec"]
        [::std::mem::align_of::<__darwin_pthread_handler_rec>() - 8usize];
    ["Offset of field: __darwin_pthread_handler_rec::__routine"]
        [::std::mem::offset_of!(__darwin_pthread_handler_rec, __routine) - 0usize];
    ["Offset of field: __darwin_pthread_handler_rec::__arg"]
        [::std::mem::offset_of!(__darwin_pthread_handler_rec, __arg) - 8usize];
    ["Offset of field: __darwin_pthread_handler_rec::__next"]
        [::std::mem::offset_of!(__darwin_pthread_handler_rec, __next) - 16usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_attr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 56usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _opaque_pthread_attr_t"][::std::mem::size_of::<_opaque_pthread_attr_t>() - 64usize];
    ["Alignment of _opaque_pthread_attr_t"]
        [::std::mem::align_of::<_opaque_pthread_attr_t>() - 8usize];
    ["Offset of field: _opaque_pthread_attr_t::__sig"]
        [::std::mem::offset_of!(_opaque_pthread_attr_t, __sig) - 0usize];
    ["Offset of field: _opaque_pthread_attr_t::__opaque"]
        [::std::mem::offset_of!(_opaque_pthread_attr_t, __opaque) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_cond_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 40usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _opaque_pthread_cond_t"][::std::mem::size_of::<_opaque_pthread_cond_t>() - 48usize];
    ["Alignment of _opaque_pthread_cond_t"]
        [::std::mem::align_of::<_opaque_pthread_cond_t>() - 8usize];
    ["Offset of field: _opaque_pthread_cond_t::__sig"]
        [::std::mem::offset_of!(_opaque_pthread_cond_t, __sig) - 0usize];
    ["Offset of field: _opaque_pthread_cond_t::__opaque"]
        [::std::mem::offset_of!(_opaque_pthread_cond_t, __opaque) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_condattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _opaque_pthread_condattr_t"]
        [::std::mem::size_of::<_opaque_pthread_condattr_t>() - 16usize];
    ["Alignment of _opaque_pthread_condattr_t"]
        [::std::mem::align_of::<_opaque_pthread_condattr_t>() - 8usize];
    ["Offset of field: _opaque_pthread_condattr_t::__sig"]
        [::std::mem::offset_of!(_opaque_pthread_condattr_t, __sig) - 0usize];
    ["Offset of field: _opaque_pthread_condattr_t::__opaque"]
        [::std::mem::offset_of!(_opaque_pthread_condattr_t, __opaque) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_mutex_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 56usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _opaque_pthread_mutex_t"][::std::mem::size_of::<_opaque_pthread_mutex_t>() - 64usize];
    ["Alignment of _opaque_pthread_mutex_t"]
        [::std::mem::align_of::<_opaque_pthread_mutex_t>() - 8usize];
    ["Offset of field: _opaque_pthread_mutex_t::__sig"]
        [::std::mem::offset_of!(_opaque_pthread_mutex_t, __sig) - 0usize];
    ["Offset of field: _opaque_pthread_mutex_t::__opaque"]
        [::std::mem::offset_of!(_opaque_pthread_mutex_t, __opaque) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_mutexattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _opaque_pthread_mutexattr_t"]
        [::std::mem::size_of::<_opaque_pthread_mutexattr_t>() - 16usize];
    ["Alignment of _opaque_pthread_mutexattr_t"]
        [::std::mem::align_of::<_opaque_pthread_mutexattr_t>() - 8usize];
    ["Offset of field: _opaque_pthread_mutexattr_t::__sig"]
        [::std::mem::offset_of!(_opaque_pthread_mutexattr_t, __sig) - 0usize];
    ["Offset of field: _opaque_pthread_mutexattr_t::__opaque"]
        [::std::mem::offset_of!(_opaque_pthread_mutexattr_t, __opaque) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_once_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _opaque_pthread_once_t"][::std::mem::size_of::<_opaque_pthread_once_t>() - 16usize];
    ["Alignment of _opaque_pthread_once_t"]
        [::std::mem::align_of::<_opaque_pthread_once_t>() - 8usize];
    ["Offset of field: _opaque_pthread_once_t::__sig"]
        [::std::mem::offset_of!(_opaque_pthread_once_t, __sig) - 0usize];
    ["Offset of field: _opaque_pthread_once_t::__opaque"]
        [::std::mem::offset_of!(_opaque_pthread_once_t, __opaque) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_rwlock_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 192usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _opaque_pthread_rwlock_t"]
        [::std::mem::size_of::<_opaque_pthread_rwlock_t>() - 200usize];
    ["Alignment of _opaque_pthread_rwlock_t"]
        [::std::mem::align_of::<_opaque_pthread_rwlock_t>() - 8usize];
    ["Offset of field: _opaque_pthread_rwlock_t::__sig"]
        [::std::mem::offset_of!(_opaque_pthread_rwlock_t, __sig) - 0usize];
    ["Offset of field: _opaque_pthread_rwlock_t::__opaque"]
        [::std::mem::offset_of!(_opaque_pthread_rwlock_t, __opaque) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_rwlockattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 16usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _opaque_pthread_rwlockattr_t"]
        [::std::mem::size_of::<_opaque_pthread_rwlockattr_t>() - 24usize];
    ["Alignment of _opaque_pthread_rwlockattr_t"]
        [::std::mem::align_of::<_opaque_pthread_rwlockattr_t>() - 8usize];
    ["Offset of field: _opaque_pthread_rwlockattr_t::__sig"]
        [::std::mem::offset_of!(_opaque_pthread_rwlockattr_t, __sig) - 0usize];
    ["Offset of field: _opaque_pthread_rwlockattr_t::__opaque"]
        [::std::mem::offset_of!(_opaque_pthread_rwlockattr_t, __opaque) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_t {
    pub __sig: ::std::os::raw::c_long,
    pub __cleanup_stack: *mut __darwin_pthread_handler_rec,
    pub __opaque: [::std::os::raw::c_char; 8176usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _opaque_pthread_t"][::std::mem::size_of::<_opaque_pthread_t>() - 8192usize];
    ["Alignment of _opaque_pthread_t"][::std::mem::align_of::<_opaque_pthread_t>() - 8usize];
    ["Offset of field: _opaque_pthread_t::__sig"]
        [::std::mem::offset_of!(_opaque_pthread_t, __sig) - 0usize];
    ["Offset of field: _opaque_pthread_t::__cleanup_stack"]
        [::std::mem::offset_of!(_opaque_pthread_t, __cleanup_stack) - 8usize];
    ["Offset of field: _opaque_pthread_t::__opaque"]
        [::std::mem::offset_of!(_opaque_pthread_t, __opaque) - 16usize];
};
pub type __darwin_pthread_attr_t = _opaque_pthread_attr_t;
pub type __darwin_pthread_cond_t = _opaque_pthread_cond_t;
pub type __darwin_pthread_condattr_t = _opaque_pthread_condattr_t;
pub type __darwin_pthread_key_t = ::std::os::raw::c_ulong;
pub type __darwin_pthread_mutex_t = _opaque_pthread_mutex_t;
pub type __darwin_pthread_mutexattr_t = _opaque_pthread_mutexattr_t;
pub type __darwin_pthread_once_t = _opaque_pthread_once_t;
pub type __darwin_pthread_rwlock_t = _opaque_pthread_rwlock_t;
pub type __darwin_pthread_rwlockattr_t = _opaque_pthread_rwlockattr_t;
pub type __darwin_pthread_t = *mut _opaque_pthread_t;
pub type int_least8_t = i8;
pub type int_least16_t = i16;
pub type int_least32_t = i32;
pub type int_least64_t = i64;
pub type uint_least8_t = u8;
pub type uint_least16_t = u16;
pub type uint_least32_t = u32;
pub type uint_least64_t = u64;
pub type int_fast8_t = i8;
pub type int_fast16_t = i16;
pub type int_fast32_t = i32;
pub type int_fast64_t = i64;
pub type uint_fast8_t = u8;
pub type uint_fast16_t = u16;
pub type uint_fast32_t = u32;
pub type uint_fast64_t = u64;
pub type intmax_t = ::std::os::raw::c_long;
pub type uintmax_t = ::std::os::raw::c_ulong;
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _OSUnalignedU16 {
    pub __val: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _OSUnalignedU16"][::std::mem::size_of::<_OSUnalignedU16>() - 2usize];
    ["Alignment of _OSUnalignedU16"][::std::mem::align_of::<_OSUnalignedU16>() - 1usize];
    ["Offset of field: _OSUnalignedU16::__val"]
        [::std::mem::offset_of!(_OSUnalignedU16, __val) - 0usize];
};
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _OSUnalignedU32 {
    pub __val: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _OSUnalignedU32"][::std::mem::size_of::<_OSUnalignedU32>() - 4usize];
    ["Alignment of _OSUnalignedU32"][::std::mem::align_of::<_OSUnalignedU32>() - 1usize];
    ["Offset of field: _OSUnalignedU32::__val"]
        [::std::mem::offset_of!(_OSUnalignedU32, __val) - 0usize];
};
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _OSUnalignedU64 {
    pub __val: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _OSUnalignedU64"][::std::mem::size_of::<_OSUnalignedU64>() - 8usize];
    ["Alignment of _OSUnalignedU64"][::std::mem::align_of::<_OSUnalignedU64>() - 1usize];
    ["Offset of field: _OSUnalignedU64::__val"]
        [::std::mem::offset_of!(_OSUnalignedU64, __val) - 0usize];
};
pub type u_char = ::std::os::raw::c_uchar;
pub type u_short = ::std::os::raw::c_ushort;
pub type u_int = ::std::os::raw::c_uint;
pub type u_long = ::std::os::raw::c_ulong;
pub type ushort = ::std::os::raw::c_ushort;
pub type uint = ::std::os::raw::c_uint;
pub type u_quad_t = u_int64_t;
pub type quad_t = i64;
pub type qaddr_t = *mut quad_t;
pub type caddr_t = *mut ::std::os::raw::c_char;
pub type daddr_t = i32;
pub type dev_t = __darwin_dev_t;
pub type fixpt_t = u_int32_t;
pub type blkcnt_t = __darwin_blkcnt_t;
pub type blksize_t = __darwin_blksize_t;
pub type gid_t = __darwin_gid_t;
pub type in_addr_t = __uint32_t;
pub type in_port_t = __uint16_t;
pub type ino_t = __darwin_ino_t;
pub type ino64_t = __darwin_ino64_t;
pub type key_t = __int32_t;
pub type mode_t = __darwin_mode_t;
pub type nlink_t = __uint16_t;
pub type id_t = __darwin_id_t;
pub type pid_t = __darwin_pid_t;
pub type off_t = __darwin_off_t;
pub type segsz_t = i32;
pub type swblk_t = i32;
pub type uid_t = __darwin_uid_t;
pub type clock_t = __darwin_clock_t;
pub type time_t = __darwin_time_t;
pub type useconds_t = __darwin_useconds_t;
pub type suseconds_t = __darwin_suseconds_t;
pub type rsize_t = __darwin_size_t;
pub type errno_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fd_set {
    pub fds_bits: [__int32_t; 32usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of fd_set"][::std::mem::size_of::<fd_set>() - 128usize];
    ["Alignment of fd_set"][::std::mem::align_of::<fd_set>() - 4usize];
    ["Offset of field: fd_set::fds_bits"][::std::mem::offset_of!(fd_set, fds_bits) - 0usize];
};
extern "C" {
    pub fn __darwin_check_fd_set_overflow(
        arg1: ::std::os::raw::c_int,
        arg2: *const ::std::os::raw::c_void,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
pub type fd_mask = __int32_t;
pub type pthread_attr_t = __darwin_pthread_attr_t;
pub type pthread_cond_t = __darwin_pthread_cond_t;
pub type pthread_condattr_t = __darwin_pthread_condattr_t;
pub type pthread_mutex_t = __darwin_pthread_mutex_t;
pub type pthread_mutexattr_t = __darwin_pthread_mutexattr_t;
pub type pthread_once_t = __darwin_pthread_once_t;
pub type pthread_rwlock_t = __darwin_pthread_rwlock_t;
pub type pthread_rwlockattr_t = __darwin_pthread_rwlockattr_t;
pub type pthread_t = __darwin_pthread_t;
pub type pthread_key_t = __darwin_pthread_key_t;
pub type fsblkcnt_t = __darwin_fsblkcnt_t;
pub type fsfilcnt_t = __darwin_fsfilcnt_t;
pub type __darwin_nl_item = ::std::os::raw::c_int;
pub type __darwin_wctrans_t = ::std::os::raw::c_int;
pub type __darwin_wctype_t = __uint32_t;
pub type wchar_t = __darwin_wchar_t;
extern "C" {
    pub fn imaxabs(j: intmax_t) -> intmax_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct imaxdiv_t {
    pub quot: intmax_t,
    pub rem: intmax_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of imaxdiv_t"][::std::mem::size_of::<imaxdiv_t>() - 16usize];
    ["Alignment of imaxdiv_t"][::std::mem::align_of::<imaxdiv_t>() - 8usize];
    ["Offset of field: imaxdiv_t::quot"][::std::mem::offset_of!(imaxdiv_t, quot) - 0usize];
    ["Offset of field: imaxdiv_t::rem"][::std::mem::offset_of!(imaxdiv_t, rem) - 8usize];
};
extern "C" {
    pub fn imaxdiv(__numer: intmax_t, __denom: intmax_t) -> imaxdiv_t;
}
extern "C" {
    pub fn strtoimax(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> intmax_t;
}
extern "C" {
    pub fn strtoumax(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> uintmax_t;
}
extern "C" {
    pub fn wcstoimax(
        __nptr: *const wchar_t,
        __endptr: *mut *mut wchar_t,
        __base: ::std::os::raw::c_int,
    ) -> intmax_t;
}
extern "C" {
    pub fn wcstoumax(
        __nptr: *const wchar_t,
        __endptr: *mut *mut wchar_t,
        __base: ::std::os::raw::c_int,
    ) -> uintmax_t;
}
pub type mdb_mode_t = mode_t;
#[doc = " Unsigned type used for mapsize, entry counts and page/transaction IDs.\n\n\tIt is normally size_t, hence the name. Defining MDB_VL32 makes it\n\tuint64_t, but do not try this unless you know what you are doing."]
pub type mdb_size_t = usize;
pub type mdb_filehandle_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MDB_env {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MDB_txn {
    _unused: [u8; 0],
}
#[doc = " @brief A handle for an individual database in the DB environment."]
pub type MDB_dbi = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MDB_cursor {
    _unused: [u8; 0],
}
#[doc = " @brief Generic structure used for passing keys and data in and out\n of the database.\n\n Values returned from the database are valid only until a subsequent\n update operation, or the end of the transaction. Do not modify or\n free them, they commonly point into the database itself.\n\n Key sizes must be between 1 and #mdb_env_get_maxkeysize() inclusive.\n The same applies to data sizes in databases with the #MDB_DUPSORT flag.\n Other data items can in theory be from 0 to 0xffffffff bytes long."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MDB_val {
    #[doc = "< size of the data item"]
    pub mv_size: usize,
    #[doc = "< address of the data item"]
    pub mv_data: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of MDB_val"][::std::mem::size_of::<MDB_val>() - 16usize];
    ["Alignment of MDB_val"][::std::mem::align_of::<MDB_val>() - 8usize];
    ["Offset of field: MDB_val::mv_size"][::std::mem::offset_of!(MDB_val, mv_size) - 0usize];
    ["Offset of field: MDB_val::mv_data"][::std::mem::offset_of!(MDB_val, mv_data) - 8usize];
};
#[doc = " @brief A callback function used to compare two keys in a database"]
pub type MDB_cmp_func = ::std::option::Option<
    unsafe extern "C" fn(a: *const MDB_val, b: *const MDB_val) -> ::std::os::raw::c_int,
>;
#[doc = " @brief A callback function used to relocate a position-dependent data item\n in a fixed-address database.\n\n The \\b newptr gives the item's desired address in\n the memory map, and \\b oldptr gives its previous address. The item's actual\n data resides at the address in \\b item.  This callback is expected to walk\n through the fields of the record in \\b item and modify any\n values based at the \\b oldptr address to be relative to the \\b newptr address.\n @param[in,out] item The item that is to be relocated.\n @param[in] oldptr The previous address.\n @param[in] newptr The new address to relocate to.\n @param[in] relctx An application-provided context, set by #mdb_set_relctx().\n @todo This feature is currently unimplemented."]
pub type MDB_rel_func = ::std::option::Option<
    unsafe extern "C" fn(
        item: *mut MDB_val,
        oldptr: *mut ::std::os::raw::c_void,
        newptr: *mut ::std::os::raw::c_void,
        relctx: *mut ::std::os::raw::c_void,
    ),
>;
#[doc = "< Position at first key/data item"]
pub const MDB_cursor_op_MDB_FIRST: MDB_cursor_op = 0;
#[doc = "< Position at first data item of current key.\nOnly for #MDB_DUPSORT"]
pub const MDB_cursor_op_MDB_FIRST_DUP: MDB_cursor_op = 1;
#[doc = "< Position at key/data pair. Only for #MDB_DUPSORT"]
pub const MDB_cursor_op_MDB_GET_BOTH: MDB_cursor_op = 2;
#[doc = "< position at key, nearest data. Only for #MDB_DUPSORT"]
pub const MDB_cursor_op_MDB_GET_BOTH_RANGE: MDB_cursor_op = 3;
#[doc = "< Return key/data at current cursor position"]
pub const MDB_cursor_op_MDB_GET_CURRENT: MDB_cursor_op = 4;
#[doc = "< Return up to a page of duplicate data items\nfrom current cursor position. Move cursor to prepare\nfor #MDB_NEXT_MULTIPLE. Only for #MDB_DUPFIXED"]
pub const MDB_cursor_op_MDB_GET_MULTIPLE: MDB_cursor_op = 5;
#[doc = "< Position at last key/data item"]
pub const MDB_cursor_op_MDB_LAST: MDB_cursor_op = 6;
#[doc = "< Position at last data item of current key.\nOnly for #MDB_DUPSORT"]
pub const MDB_cursor_op_MDB_LAST_DUP: MDB_cursor_op = 7;
#[doc = "< Position at next data item"]
pub const MDB_cursor_op_MDB_NEXT: MDB_cursor_op = 8;
#[doc = "< Position at next data item of current key.\nOnly for #MDB_DUPSORT"]
pub const MDB_cursor_op_MDB_NEXT_DUP: MDB_cursor_op = 9;
#[doc = "< Return up to a page of duplicate data items\nfrom next cursor position. Move cursor to prepare\nfor #MDB_NEXT_MULTIPLE. Only for #MDB_DUPFIXED"]
pub const MDB_cursor_op_MDB_NEXT_MULTIPLE: MDB_cursor_op = 10;
#[doc = "< Position at first data item of next key"]
pub const MDB_cursor_op_MDB_NEXT_NODUP: MDB_cursor_op = 11;
#[doc = "< Position at previous data item"]
pub const MDB_cursor_op_MDB_PREV: MDB_cursor_op = 12;
#[doc = "< Position at previous data item of current key.\nOnly for #MDB_DUPSORT"]
pub const MDB_cursor_op_MDB_PREV_DUP: MDB_cursor_op = 13;
#[doc = "< Position at last data item of previous key"]
pub const MDB_cursor_op_MDB_PREV_NODUP: MDB_cursor_op = 14;
#[doc = "< Position at specified key"]
pub const MDB_cursor_op_MDB_SET: MDB_cursor_op = 15;
#[doc = "< Position at specified key, return key + data"]
pub const MDB_cursor_op_MDB_SET_KEY: MDB_cursor_op = 16;
#[doc = "< Position at first key greater than or equal to specified key."]
pub const MDB_cursor_op_MDB_SET_RANGE: MDB_cursor_op = 17;
#[doc = "< Position at previous page and return up to\na page of duplicate data items. Only for #MDB_DUPFIXED"]
pub const MDB_cursor_op_MDB_PREV_MULTIPLE: MDB_cursor_op = 18;
#[doc = " @brief Cursor Get operations.\n\n\tThis is the set of all operations for retrieving data\n\tusing a cursor."]
pub type MDB_cursor_op = ::std::os::raw::c_uint;
#[doc = " @brief Statistics for a database in the environment"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MDB_stat {
    #[doc = "< Size of a database page.\nThis is currently the same for all databases."]
    pub ms_psize: ::std::os::raw::c_uint,
    #[doc = "< Depth (height) of the B-tree"]
    pub ms_depth: ::std::os::raw::c_uint,
    #[doc = "< Number of internal (non-leaf) pages"]
    pub ms_branch_pages: mdb_size_t,
    #[doc = "< Number of leaf pages"]
    pub ms_leaf_pages: mdb_size_t,
    #[doc = "< Number of overflow pages"]
    pub ms_overflow_pages: mdb_size_t,
    #[doc = "< Number of data items"]
    pub ms_entries: mdb_size_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of MDB_stat"][::std::mem::size_of::<MDB_stat>() - 40usize];
    ["Alignment of MDB_stat"][::std::mem::align_of::<MDB_stat>() - 8usize];
    ["Offset of field: MDB_stat::ms_psize"][::std::mem::offset_of!(MDB_stat, ms_psize) - 0usize];
    ["Offset of field: MDB_stat::ms_depth"][::std::mem::offset_of!(MDB_stat, ms_depth) - 4usize];
    ["Offset of field: MDB_stat::ms_branch_pages"]
        [::std::mem::offset_of!(MDB_stat, ms_branch_pages) - 8usize];
    ["Offset of field: MDB_stat::ms_leaf_pages"]
        [::std::mem::offset_of!(MDB_stat, ms_leaf_pages) - 16usize];
    ["Offset of field: MDB_stat::ms_overflow_pages"]
        [::std::mem::offset_of!(MDB_stat, ms_overflow_pages) - 24usize];
    ["Offset of field: MDB_stat::ms_entries"]
        [::std::mem::offset_of!(MDB_stat, ms_entries) - 32usize];
};
#[doc = " @brief Information about the environment"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MDB_envinfo {
    #[doc = "< Address of map, if fixed"]
    pub me_mapaddr: *mut ::std::os::raw::c_void,
    #[doc = "< Size of the data memory map"]
    pub me_mapsize: mdb_size_t,
    #[doc = "< ID of the last used page"]
    pub me_last_pgno: mdb_size_t,
    #[doc = "< ID of the last committed transaction"]
    pub me_last_txnid: mdb_size_t,
    #[doc = "< max reader slots in the environment"]
    pub me_maxreaders: ::std::os::raw::c_uint,
    #[doc = "< max reader slots used in the environment"]
    pub me_numreaders: ::std::os::raw::c_uint,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of MDB_envinfo"][::std::mem::size_of::<MDB_envinfo>() - 40usize];
    ["Alignment of MDB_envinfo"][::std::mem::align_of::<MDB_envinfo>() - 8usize];
    ["Offset of field: MDB_envinfo::me_mapaddr"]
        [::std::mem::offset_of!(MDB_envinfo, me_mapaddr) - 0usize];
    ["Offset of field: MDB_envinfo::me_mapsize"]
        [::std::mem::offset_of!(MDB_envinfo, me_mapsize) - 8usize];
    ["Offset of field: MDB_envinfo::me_last_pgno"]
        [::std::mem::offset_of!(MDB_envinfo, me_last_pgno) - 16usize];
    ["Offset of field: MDB_envinfo::me_last_txnid"]
        [::std::mem::offset_of!(MDB_envinfo, me_last_txnid) - 24usize];
    ["Offset of field: MDB_envinfo::me_maxreaders"]
        [::std::mem::offset_of!(MDB_envinfo, me_maxreaders) - 32usize];
    ["Offset of field: MDB_envinfo::me_numreaders"]
        [::std::mem::offset_of!(MDB_envinfo, me_numreaders) - 36usize];
};
extern "C" {
    #[doc = " @brief Return the LMDB library version information.\n\n @param[out] major if non-NULL, the library major version number is copied here\n @param[out] minor if non-NULL, the library minor version number is copied here\n @param[out] patch if non-NULL, the library patch version number is copied here\n @retval \"version string\" The library version as a string"]
    pub fn mdb_version(
        major: *mut ::std::os::raw::c_int,
        minor: *mut ::std::os::raw::c_int,
        patch: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Return a string describing a given error code.\n\n This function is a superset of the ANSI C X3.159-1989 (ANSI C) strerror(3)\n function. If the error code is greater than or equal to 0, then the string\n returned by the system function strerror(3) is returned. If the error code\n is less than 0, an error string corresponding to the LMDB library error is\n returned. See @ref errors for a list of LMDB-specific error codes.\n @param[in] err The error code\n @retval \"error message\" The description of the error"]
    pub fn mdb_strerror(err: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Create an LMDB environment handle.\n\n This function allocates memory for a #MDB_env structure. To release\n the allocated memory and discard the handle, call #mdb_env_close().\n Before the handle may be used, it must be opened using #mdb_env_open().\n Various other options may also need to be set before opening the handle,\n e.g. #mdb_env_set_mapsize(), #mdb_env_set_maxreaders(), #mdb_env_set_maxdbs(),\n depending on usage requirements.\n @param[out] env The address where the new handle will be stored\n @return A non-zero error value on failure and 0 on success."]
    pub fn mdb_env_create(env: *mut *mut MDB_env) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Open an environment handle.\n\n If this function fails, #mdb_env_close() must be called to discard the #MDB_env handle.\n @param[in] env An environment handle returned by #mdb_env_create()\n @param[in] path The directory in which the database files reside. This\n directory must already exist and be writable.\n @param[in] flags Special options for this environment. This parameter\n must be set to 0 or by bitwise OR'ing together one or more of the\n values described here.\n Flags set by mdb_env_set_flags() are also used.\n <ul>\n\t<li>#MDB_FIXEDMAP\n      use a fixed address for the mmap region. This flag must be specified\n      when creating the environment, and is stored persistently in the environment.\n\t\tIf successful, the memory map will always reside at the same virtual address\n\t\tand pointers used to reference data items in the database will be constant\n\t\tacross multiple invocations. This option may not always work, depending on\n\t\thow the operating system has allocated memory to shared libraries and other uses.\n\t\tThe feature is highly experimental.\n\t<li>#MDB_NOSUBDIR\n\t\tBy default, LMDB creates its environment in a directory whose\n\t\tpathname is given in \\b path, and creates its data and lock files\n\t\tunder that directory. With this option, \\b path is used as-is for\n\t\tthe database main data file. The database lock file is the \\b path\n\t\twith \"-lock\" appended.\n\t<li>#MDB_RDONLY\n\t\tOpen the environment in read-only mode. No write operations will be\n\t\tallowed. LMDB will still modify the lock file - except on read-only\n\t\tfilesystems, where LMDB does not use locks.\n\t<li>#MDB_WRITEMAP\n\t\tUse a writeable memory map unless MDB_RDONLY is set. This uses\n\t\tfewer mallocs but loses protection from application bugs\n\t\tlike wild pointer writes and other bad updates into the database.\n\t\tThis may be slightly faster for DBs that fit entirely in RAM, but\n\t\tis slower for DBs larger than RAM.\n\t\tIncompatible with nested transactions.\n\t\tDo not mix processes with and without MDB_WRITEMAP on the same\n\t\tenvironment.  This can defeat durability (#mdb_env_sync etc).\n\t<li>#MDB_NOMETASYNC\n\t\tFlush system buffers to disk only once per transaction, omit the\n\t\tmetadata flush. Defer that until the system flushes files to disk,\n\t\tor next non-MDB_RDONLY commit or #mdb_env_sync(). This optimization\n\t\tmaintains database integrity, but a system crash may undo the last\n\t\tcommitted transaction. I.e. it preserves the ACI (atomicity,\n\t\tconsistency, isolation) but not D (durability) database property.\n\t\tThis flag may be changed at any time using #mdb_env_set_flags().\n\t<li>#MDB_NOSYNC\n\t\tDon't flush system buffers to disk when committing a transaction.\n\t\tThis optimization means a system crash can corrupt the database or\n\t\tlose the last transactions if buffers are not yet flushed to disk.\n\t\tThe risk is governed by how often the system flushes dirty buffers\n\t\tto disk and how often #mdb_env_sync() is called.  However, if the\n\t\tfilesystem preserves write order and the #MDB_WRITEMAP flag is not\n\t\tused, transactions exhibit ACI (atomicity, consistency, isolation)\n\t\tproperties and only lose D (durability).  I.e. database integrity\n\t\tis maintained, but a system crash may undo the final transactions.\n\t\tNote that (#MDB_NOSYNC | #MDB_WRITEMAP) leaves the system with no\n\t\thint for when to write transactions to disk, unless #mdb_env_sync()\n\t\tis called. (#MDB_MAPASYNC | #MDB_WRITEMAP) may be preferable.\n\t\tThis flag may be changed at any time using #mdb_env_set_flags().\n\t<li>#MDB_MAPASYNC\n\t\tWhen using #MDB_WRITEMAP, use asynchronous flushes to disk.\n\t\tAs with #MDB_NOSYNC, a system crash can then corrupt the\n\t\tdatabase or lose the last transactions. Calling #mdb_env_sync()\n\t\tensures on-disk database integrity until next commit.\n\t\tThis flag may be changed at any time using #mdb_env_set_flags().\n\t<li>#MDB_NOTLS\n\t\tDon't use Thread-Local Storage. Tie reader locktable slots to\n\t\t#MDB_txn objects instead of to threads. I.e. #mdb_txn_reset() keeps\n\t\tthe slot reserved for the #MDB_txn object. A thread may use parallel\n\t\tread-only transactions. A read-only transaction may span threads if\n\t\tthe user synchronizes its use. Applications that multiplex many\n\t\tuser threads over individual OS threads need this option. Such an\n\t\tapplication must also serialize the write transactions in an OS\n\t\tthread, since LMDB's write locking is unaware of the user threads.\n\t<li>#MDB_NOLOCK\n\t\tDon't do any locking. If concurrent access is anticipated, the\n\t\tcaller must manage all concurrency itself. For proper operation\n\t\tthe caller must enforce single-writer semantics, and must ensure\n\t\tthat no readers are using old transactions while a writer is\n\t\tactive. The simplest approach is to use an exclusive lock so that\n\t\tno readers may be active at all when a writer begins.\n\t<li>#MDB_NORDAHEAD\n\t\tTurn off readahead. Most operating systems perform readahead on\n\t\tread requests by default. This option turns it off if the OS\n\t\tsupports it. Turning it off may help random read performance\n\t\twhen the DB is larger than RAM and system RAM is full.\n\t\tThe option is not implemented on Windows.\n\t<li>#MDB_NOMEMINIT\n\t\tDon't initialize malloc'd memory before writing to unused spaces\n\t\tin the data file. By default, memory for pages written to the data\n\t\tfile is obtained using malloc. While these pages may be reused in\n\t\tsubsequent transactions, freshly malloc'd pages will be initialized\n\t\tto zeroes before use. This avoids persisting leftover data from other\n\t\tcode (that used the heap and subsequently freed the memory) into the\n\t\tdata file. Note that many other system libraries may allocate\n\t\tand free memory from the heap for arbitrary uses. E.g., stdio may\n\t\tuse the heap for file I/O buffers. This initialization step has a\n\t\tmodest performance cost so some applications may want to disable\n\t\tit using this flag. This option can be a problem for applications\n\t\twhich handle sensitive data like passwords, and it makes memory\n\t\tcheckers like Valgrind noisy. This flag is not needed with #MDB_WRITEMAP,\n\t\twhich writes directly to the mmap instead of using malloc for pages. The\n\t\tinitialization is also skipped if #MDB_RESERVE is used; the\n\t\tcaller is expected to overwrite all of the memory that was\n\t\treserved in that case.\n\t\tThis flag may be changed at any time using #mdb_env_set_flags().\n\t<li>#MDB_PREVSNAPSHOT\n\t\tOpen the environment with the previous snapshot rather than the latest\n\t\tone. This loses the latest transaction, but may help work around some\n\t\ttypes of corruption. If opened with write access, this must be the\n\t\tonly process using the environment. This flag is automatically reset\n\t\tafter a write transaction is successfully committed.\n </ul>\n @param[in] mode The UNIX permissions to set on created files and semaphores.\n This parameter is ignored on Windows.\n @return A non-zero error value on failure and 0 on success. Some possible\n errors are:\n <ul>\n\t<li>#MDB_VERSION_MISMATCH - the version of the LMDB library doesn't match the\n\tversion that created the database environment.\n\t<li>#MDB_INVALID - the environment file headers are corrupted.\n\t<li>ENOENT - the directory specified by the path parameter doesn't exist.\n\t<li>EACCES - the user didn't have permission to access the environment files.\n\t<li>EAGAIN - the environment was locked by another process.\n </ul>"]
    pub fn mdb_env_open(
        env: *mut MDB_env,
        path: *const ::std::os::raw::c_char,
        flags: ::std::os::raw::c_uint,
        mode: mdb_mode_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Copy an LMDB environment to the specified path.\n\n This function may be used to make a backup of an existing environment.\n No lockfile is created, since it gets recreated at need.\n @note This call can trigger significant file size growth if run in\n parallel with write transactions, because it employs a read-only\n transaction. See long-lived transactions under @ref caveats_sec.\n @param[in] env An environment handle returned by #mdb_env_create(). It\n must have already been opened successfully.\n @param[in] path The directory in which the copy will reside. This\n directory must already exist and be writable but must otherwise be\n empty.\n @return A non-zero error value on failure and 0 on success."]
    pub fn mdb_env_copy(
        env: *mut MDB_env,
        path: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Copy an LMDB environment to the specified file descriptor.\n\n This function may be used to make a backup of an existing environment.\n No lockfile is created, since it gets recreated at need.\n @note This call can trigger significant file size growth if run in\n parallel with write transactions, because it employs a read-only\n transaction. See long-lived transactions under @ref caveats_sec.\n @param[in] env An environment handle returned by #mdb_env_create(). It\n must have already been opened successfully.\n @param[in] fd The filedescriptor to write the copy to. It must\n have already been opened for Write access.\n @return A non-zero error value on failure and 0 on success."]
    pub fn mdb_env_copyfd(env: *mut MDB_env, fd: mdb_filehandle_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Copy an LMDB environment to the specified path, with options.\n\n This function may be used to make a backup of an existing environment.\n No lockfile is created, since it gets recreated at need.\n @note This call can trigger significant file size growth if run in\n parallel with write transactions, because it employs a read-only\n transaction. See long-lived transactions under @ref caveats_sec.\n @param[in] env An environment handle returned by #mdb_env_create(). It\n must have already been opened successfully.\n @param[in] path The directory in which the copy will reside. This\n directory must already exist and be writable but must otherwise be\n empty.\n @param[in] flags Special options for this operation. This parameter\n must be set to 0 or by bitwise OR'ing together one or more of the\n values described here.\n <ul>\n\t<li>#MDB_CP_COMPACT - Perform compaction while copying: omit free\n\t\tpages and sequentially renumber all pages in output. This option\n\t\tconsumes more CPU and runs more slowly than the default.\n\t\tCurrently it fails if the environment has suffered a page leak.\n </ul>\n @return A non-zero error value on failure and 0 on success."]
    pub fn mdb_env_copy2(
        env: *mut MDB_env,
        path: *const ::std::os::raw::c_char,
        flags: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Copy an LMDB environment to the specified file descriptor,\n\twith options.\n\n This function may be used to make a backup of an existing environment.\n No lockfile is created, since it gets recreated at need. See\n #mdb_env_copy2() for further details.\n @note This call can trigger significant file size growth if run in\n parallel with write transactions, because it employs a read-only\n transaction. See long-lived transactions under @ref caveats_sec.\n @param[in] env An environment handle returned by #mdb_env_create(). It\n must have already been opened successfully.\n @param[in] fd The filedescriptor to write the copy to. It must\n have already been opened for Write access.\n @param[in] flags Special options for this operation.\n See #mdb_env_copy2() for options.\n @return A non-zero error value on failure and 0 on success."]
    pub fn mdb_env_copyfd2(
        env: *mut MDB_env,
        fd: mdb_filehandle_t,
        flags: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Return statistics about the LMDB environment.\n\n @param[in] env An environment handle returned by #mdb_env_create()\n @param[out] stat The address of an #MDB_stat structure\n \twhere the statistics will be copied"]
    pub fn mdb_env_stat(env: *mut MDB_env, stat: *mut MDB_stat) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Return information about the LMDB environment.\n\n @param[in] env An environment handle returned by #mdb_env_create()\n @param[out] stat The address of an #MDB_envinfo structure\n \twhere the information will be copied"]
    pub fn mdb_env_info(env: *mut MDB_env, stat: *mut MDB_envinfo) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Flush the data buffers to disk.\n\n Data is always written to disk when #mdb_txn_commit() is called,\n but the operating system may keep it buffered. LMDB always flushes\n the OS buffers upon commit as well, unless the environment was\n opened with #MDB_NOSYNC or in part #MDB_NOMETASYNC. This call is\n not valid if the environment was opened with #MDB_RDONLY.\n @param[in] env An environment handle returned by #mdb_env_create()\n @param[in] force If non-zero, force a synchronous flush.  Otherwise\n  if the environment has the #MDB_NOSYNC flag set the flushes\n\twill be omitted, and with #MDB_MAPASYNC they will be asynchronous.\n @return A non-zero error value on failure and 0 on success. Some possible\n errors are:\n <ul>\n\t<li>EACCES - the environment is read-only.\n\t<li>EINVAL - an invalid parameter was specified.\n\t<li>EIO - an error occurred during synchronization.\n </ul>"]
    pub fn mdb_env_sync(env: *mut MDB_env, force: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Close the environment and release the memory map.\n\n Only a single thread may call this function. All transactions, databases,\n and cursors must already be closed before calling this function. Attempts to\n use any such handles after calling this function will cause a SIGSEGV.\n The environment handle will be freed and must not be used again after this call.\n @param[in] env An environment handle returned by #mdb_env_create()"]
    pub fn mdb_env_close(env: *mut MDB_env);
}
extern "C" {
    #[doc = " @brief Set environment flags.\n\n This may be used to set some flags in addition to those from\n #mdb_env_open(), or to unset these flags.  If several threads\n change the flags at the same time, the result is undefined.\n @param[in] env An environment handle returned by #mdb_env_create()\n @param[in] flags The flags to change, bitwise OR'ed together\n @param[in] onoff A non-zero value sets the flags, zero clears them.\n @return A non-zero error value on failure and 0 on success. Some possible\n errors are:\n <ul>\n\t<li>EINVAL - an invalid parameter was specified.\n </ul>"]
    pub fn mdb_env_set_flags(
        env: *mut MDB_env,
        flags: ::std::os::raw::c_uint,
        onoff: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Get environment flags.\n\n @param[in] env An environment handle returned by #mdb_env_create()\n @param[out] flags The address of an integer to store the flags\n @return A non-zero error value on failure and 0 on success. Some possible\n errors are:\n <ul>\n\t<li>EINVAL - an invalid parameter was specified.\n </ul>"]
    pub fn mdb_env_get_flags(
        env: *mut MDB_env,
        flags: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Return the path that was used in #mdb_env_open().\n\n @param[in] env An environment handle returned by #mdb_env_create()\n @param[out] path Address of a string pointer to contain the path. This\n is the actual string in the environment, not a copy. It should not be\n altered in any way.\n @return A non-zero error value on failure and 0 on success. Some possible\n errors are:\n <ul>\n\t<li>EINVAL - an invalid parameter was specified.\n </ul>"]
    pub fn mdb_env_get_path(
        env: *mut MDB_env,
        path: *mut *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Return the filedescriptor for the given environment.\n\n This function may be called after fork(), so the descriptor can be\n closed before exec*().  Other LMDB file descriptors have FD_CLOEXEC.\n (Until LMDB 0.9.18, only the lockfile had that.)\n\n @param[in] env An environment handle returned by #mdb_env_create()\n @param[out] fd Address of a mdb_filehandle_t to contain the descriptor.\n @return A non-zero error value on failure and 0 on success. Some possible\n errors are:\n <ul>\n\t<li>EINVAL - an invalid parameter was specified.\n </ul>"]
    pub fn mdb_env_get_fd(env: *mut MDB_env, fd: *mut mdb_filehandle_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set the size of the memory map to use for this environment.\n\n The size should be a multiple of the OS page size. The default is\n 10485760 bytes. The size of the memory map is also the maximum size\n of the database. The value should be chosen as large as possible,\n to accommodate future growth of the database.\n This function should be called after #mdb_env_create() and before #mdb_env_open().\n It may be called at later times if no transactions are active in\n this process. Note that the library does not check for this condition,\n the caller must ensure it explicitly.\n\n The new size takes effect immediately for the current process but\n will not be persisted to any others until a write transaction has been\n committed by the current process. Also, only mapsize increases are\n persisted into the environment.\n\n If the mapsize is increased by another process, and data has grown\n beyond the range of the current mapsize, #mdb_txn_begin() will\n return #MDB_MAP_RESIZED. This function may be called with a size\n of zero to adopt the new size.\n\n Any attempt to set a size smaller than the space already consumed\n by the environment will be silently changed to the current size of the used space.\n @param[in] env An environment handle returned by #mdb_env_create()\n @param[in] size The size in bytes\n @return A non-zero error value on failure and 0 on success. Some possible\n errors are:\n <ul>\n\t<li>EINVAL - an invalid parameter was specified, or the environment has\n   \tan active write transaction.\n </ul>"]
    pub fn mdb_env_set_mapsize(env: *mut MDB_env, size: mdb_size_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set the maximum number of threads/reader slots for the environment.\n\n This defines the number of slots in the lock table that is used to track readers in the\n the environment. The default is 126.\n Starting a read-only transaction normally ties a lock table slot to the\n current thread until the environment closes or the thread exits. If\n MDB_NOTLS is in use, #mdb_txn_begin() instead ties the slot to the\n MDB_txn object until it or the #MDB_env object is destroyed.\n This function may only be called after #mdb_env_create() and before #mdb_env_open().\n @param[in] env An environment handle returned by #mdb_env_create()\n @param[in] readers The maximum number of reader lock table slots\n @return A non-zero error value on failure and 0 on success. Some possible\n errors are:\n <ul>\n\t<li>EINVAL - an invalid parameter was specified, or the environment is already open.\n </ul>"]
    pub fn mdb_env_set_maxreaders(
        env: *mut MDB_env,
        readers: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Get the maximum number of threads/reader slots for the environment.\n\n @param[in] env An environment handle returned by #mdb_env_create()\n @param[out] readers Address of an integer to store the number of readers\n @return A non-zero error value on failure and 0 on success. Some possible\n errors are:\n <ul>\n\t<li>EINVAL - an invalid parameter was specified.\n </ul>"]
    pub fn mdb_env_get_maxreaders(
        env: *mut MDB_env,
        readers: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set the maximum number of named databases for the environment.\n\n This function is only needed if multiple databases will be used in the\n environment. Simpler applications that use the environment as a single\n unnamed database can ignore this option.\n This function may only be called after #mdb_env_create() and before #mdb_env_open().\n\n Currently a moderate number of slots are cheap but a huge number gets\n expensive: 7-120 words per transaction, and every #mdb_dbi_open()\n does a linear search of the opened slots.\n @param[in] env An environment handle returned by #mdb_env_create()\n @param[in] dbs The maximum number of databases\n @return A non-zero error value on failure and 0 on success. Some possible\n errors are:\n <ul>\n\t<li>EINVAL - an invalid parameter was specified, or the environment is already open.\n </ul>"]
    pub fn mdb_env_set_maxdbs(env: *mut MDB_env, dbs: MDB_dbi) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Get the maximum size of keys and #MDB_DUPSORT data we can write.\n\n Depends on the compile-time constant #MDB_MAXKEYSIZE. Default 511.\n See @ref MDB_val.\n @param[in] env An environment handle returned by #mdb_env_create()\n @return The maximum size of a key we can write"]
    pub fn mdb_env_get_maxkeysize(env: *mut MDB_env) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set application information associated with the #MDB_env.\n\n @param[in] env An environment handle returned by #mdb_env_create()\n @param[in] ctx An arbitrary pointer for whatever the application needs.\n @return A non-zero error value on failure and 0 on success."]
    pub fn mdb_env_set_userctx(
        env: *mut MDB_env,
        ctx: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Get the application information associated with the #MDB_env.\n\n @param[in] env An environment handle returned by #mdb_env_create()\n @return The pointer set by #mdb_env_set_userctx()."]
    pub fn mdb_env_get_userctx(env: *mut MDB_env) -> *mut ::std::os::raw::c_void;
}
#[doc = " @brief A callback function for most LMDB assert() failures,\n called before printing the message and aborting.\n\n @param[in] env An environment handle returned by #mdb_env_create().\n @param[in] msg The assertion message, not including newline."]
pub type MDB_assert_func = ::std::option::Option<
    unsafe extern "C" fn(env: *mut MDB_env, msg: *const ::std::os::raw::c_char),
>;
extern "C" {
    #[doc = " Set or reset the assert() callback of the environment.\n Disabled if liblmdb is built with NDEBUG.\n @note This hack should become obsolete as lmdb's error handling matures.\n @param[in] env An environment handle returned by #mdb_env_create().\n @param[in] func An #MDB_assert_func function, or 0.\n @return A non-zero error value on failure and 0 on success."]
    pub fn mdb_env_set_assert(env: *mut MDB_env, func: MDB_assert_func) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Create a transaction for use with the environment.\n\n The transaction handle may be discarded using #mdb_txn_abort() or #mdb_txn_commit().\n @note A transaction and its cursors must only be used by a single\n thread, and a thread may only have a single transaction at a time.\n If #MDB_NOTLS is in use, this does not apply to read-only transactions.\n @note Cursors may not span transactions.\n @param[in] env An environment handle returned by #mdb_env_create()\n @param[in] parent If this parameter is non-NULL, the new transaction\n will be a nested transaction, with the transaction indicated by \\b parent\n as its parent. Transactions may be nested to any level. A parent\n transaction and its cursors may not issue any other operations than\n mdb_txn_commit and mdb_txn_abort while it has active child transactions.\n @param[in] flags Special options for this transaction. This parameter\n must be set to 0 or by bitwise OR'ing together one or more of the\n values described here.\n <ul>\n\t<li>#MDB_RDONLY\n\t\tThis transaction will not perform any write operations.\n\t<li>#MDB_NOSYNC\n\t\tDon't flush system buffers to disk when committing this transaction.\n\t<li>#MDB_NOMETASYNC\n\t\tFlush system buffers but omit metadata flush when committing this transaction.\n </ul>\n @param[out] txn Address where the new #MDB_txn handle will be stored\n @return A non-zero error value on failure and 0 on success. Some possible\n errors are:\n <ul>\n\t<li>#MDB_PANIC - a fatal error occurred earlier and the environment\n\t\tmust be shut down.\n\t<li>#MDB_MAP_RESIZED - another process wrote data beyond this MDB_env's\n\t\tmapsize and this environment's map must be resized as well.\n\t\tSee #mdb_env_set_mapsize().\n\t<li>#MDB_READERS_FULL - a read-only transaction was requested and\n\t\tthe reader lock table is full. See #mdb_env_set_maxreaders().\n\t<li>ENOMEM - out of memory.\n </ul>"]
    pub fn mdb_txn_begin(
        env: *mut MDB_env,
        parent: *mut MDB_txn,
        flags: ::std::os::raw::c_uint,
        txn: *mut *mut MDB_txn,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Returns the transaction's #MDB_env\n\n @param[in] txn A transaction handle returned by #mdb_txn_begin()"]
    pub fn mdb_txn_env(txn: *mut MDB_txn) -> *mut MDB_env;
}
extern "C" {
    #[doc = " @brief Return the transaction's ID.\n\n This returns the identifier associated with this transaction. For a\n read-only transaction, this corresponds to the snapshot being read;\n concurrent readers will frequently have the same transaction ID.\n\n @param[in] txn A transaction handle returned by #mdb_txn_begin()\n @return A transaction ID, valid if input is an active transaction."]
    pub fn mdb_txn_id(txn: *mut MDB_txn) -> mdb_size_t;
}
extern "C" {
    #[doc = " @brief Commit all the operations of a transaction into the database.\n\n The transaction handle is freed. It and its cursors must not be used\n again after this call, except with #mdb_cursor_renew().\n @note Earlier documentation incorrectly said all cursors would be freed.\n Only write-transactions free cursors.\n @param[in] txn A transaction handle returned by #mdb_txn_begin()\n @return A non-zero error value on failure and 0 on success. Some possible\n errors are:\n <ul>\n\t<li>EINVAL - an invalid parameter was specified.\n\t<li>ENOSPC - no more disk space.\n\t<li>EIO - a low-level I/O error occurred while writing.\n\t<li>ENOMEM - out of memory.\n </ul>"]
    pub fn mdb_txn_commit(txn: *mut MDB_txn) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Abandon all the operations of the transaction instead of saving them.\n\n The transaction handle is freed. It and its cursors must not be used\n again after this call, except with #mdb_cursor_renew().\n @note Earlier documentation incorrectly said all cursors would be freed.\n Only write-transactions free cursors.\n @param[in] txn A transaction handle returned by #mdb_txn_begin()"]
    pub fn mdb_txn_abort(txn: *mut MDB_txn);
}
extern "C" {
    #[doc = " @brief Reset a read-only transaction.\n\n Abort the transaction like #mdb_txn_abort(), but keep the transaction\n handle. #mdb_txn_renew() may reuse the handle. This saves allocation\n overhead if the process will start a new read-only transaction soon,\n and also locking overhead if #MDB_NOTLS is in use. The reader table\n lock is released, but the table slot stays tied to its thread or\n #MDB_txn. Use mdb_txn_abort() to discard a reset handle, and to free\n its lock table slot if MDB_NOTLS is in use.\n Cursors opened within the transaction must not be used\n again after this call, except with #mdb_cursor_renew().\n Reader locks generally don't interfere with writers, but they keep old\n versions of database pages allocated. Thus they prevent the old pages\n from being reused when writers commit new data, and so under heavy load\n the database size may grow much more rapidly than otherwise.\n @param[in] txn A transaction handle returned by #mdb_txn_begin()"]
    pub fn mdb_txn_reset(txn: *mut MDB_txn);
}
extern "C" {
    #[doc = " @brief Renew a read-only transaction.\n\n This acquires a new reader lock for a transaction handle that had been\n released by #mdb_txn_reset(). It must be called before a reset transaction\n may be used again.\n @param[in] txn A transaction handle returned by #mdb_txn_begin()\n @return A non-zero error value on failure and 0 on success. Some possible\n errors are:\n <ul>\n\t<li>#MDB_PANIC - a fatal error occurred earlier and the environment\n\t\tmust be shut down.\n\t<li>EINVAL - an invalid parameter was specified.\n </ul>"]
    pub fn mdb_txn_renew(txn: *mut MDB_txn) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Open a database in the environment.\n\n A database handle denotes the name and parameters of a database,\n independently of whether such a database exists.\n The database handle may be discarded by calling #mdb_dbi_close().\n The old database handle is returned if the database was already open.\n The handle may only be closed once.\n\n The database handle will be private to the current transaction until\n the transaction is successfully committed. If the transaction is\n aborted the handle will be closed automatically.\n After a successful commit the handle will reside in the shared\n environment, and may be used by other transactions.\n\n This function must not be called from multiple concurrent\n transactions in the same process. A transaction that uses\n this function must finish (either commit or abort) before\n any other transaction in the process may use this function.\n\n To use named databases (with name != NULL), #mdb_env_set_maxdbs()\n must be called before opening the environment.  Database names are\n keys in the unnamed database, and may be read but not written.\n\n @param[in] txn A transaction handle returned by #mdb_txn_begin()\n @param[in] name The name of the database to open. If only a single\n \tdatabase is needed in the environment, this value may be NULL.\n @param[in] flags Special options for this database. This parameter\n must be set to 0 or by bitwise OR'ing together one or more of the\n values described here.\n <ul>\n\t<li>#MDB_REVERSEKEY\n\t\tKeys are strings to be compared in reverse order, from the end\n\t\tof the strings to the beginning. By default, Keys are treated as strings and\n\t\tcompared from beginning to end.\n\t<li>#MDB_DUPSORT\n\t\tDuplicate keys may be used in the database. (Or, from another perspective,\n\t\tkeys may have multiple data items, stored in sorted order.) By default\n\t\tkeys must be unique and may have only a single data item.\n\t<li>#MDB_INTEGERKEY\n\t\tKeys are binary integers in native byte order, either unsigned int\n\t\tor #mdb_size_t, and will be sorted as such.\n\t\t(lmdb expects 32-bit int <= size_t <= 32/64-bit mdb_size_t.)\n\t\tThe keys must all be of the same size.\n\t<li>#MDB_DUPFIXED\n\t\tThis flag may only be used in combination with #MDB_DUPSORT. This option\n\t\ttells the library that the data items for this database are all the same\n\t\tsize, which allows further optimizations in storage and retrieval. When\n\t\tall data items are the same size, the #MDB_GET_MULTIPLE, #MDB_NEXT_MULTIPLE\n\t\tand #MDB_PREV_MULTIPLE cursor operations may be used to retrieve multiple\n\t\titems at once.\n\t<li>#MDB_INTEGERDUP\n\t\tThis option specifies that duplicate data items are binary integers,\n\t\tsimilar to #MDB_INTEGERKEY keys.\n\t<li>#MDB_REVERSEDUP\n\t\tThis option specifies that duplicate data items should be compared as\n\t\tstrings in reverse order.\n\t<li>#MDB_CREATE\n\t\tCreate the named database if it doesn't exist. This option is not\n\t\tallowed in a read-only transaction or a read-only environment.\n </ul>\n @param[out] dbi Address where the new #MDB_dbi handle will be stored\n @return A non-zero error value on failure and 0 on success. Some possible\n errors are:\n <ul>\n\t<li>#MDB_NOTFOUND - the specified database doesn't exist in the environment\n\t\tand #MDB_CREATE was not specified.\n\t<li>#MDB_DBS_FULL - too many databases have been opened. See #mdb_env_set_maxdbs().\n </ul>"]
    pub fn mdb_dbi_open(
        txn: *mut MDB_txn,
        name: *const ::std::os::raw::c_char,
        flags: ::std::os::raw::c_uint,
        dbi: *mut MDB_dbi,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Retrieve statistics for a database.\n\n @param[in] txn A transaction handle returned by #mdb_txn_begin()\n @param[in] dbi A database handle returned by #mdb_dbi_open()\n @param[out] stat The address of an #MDB_stat structure\n \twhere the statistics will be copied\n @return A non-zero error value on failure and 0 on success. Some possible\n errors are:\n <ul>\n\t<li>EINVAL - an invalid parameter was specified.\n </ul>"]
    pub fn mdb_stat(txn: *mut MDB_txn, dbi: MDB_dbi, stat: *mut MDB_stat) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Retrieve the DB flags for a database handle.\n\n @param[in] txn A transaction handle returned by #mdb_txn_begin()\n @param[in] dbi A database handle returned by #mdb_dbi_open()\n @param[out] flags Address where the flags will be returned.\n @return A non-zero error value on failure and 0 on success."]
    pub fn mdb_dbi_flags(
        txn: *mut MDB_txn,
        dbi: MDB_dbi,
        flags: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Close a database handle. Normally unnecessary. Use with care:\n\n This call is not mutex protected. Handles should only be closed by\n a single thread, and only if no other threads are going to reference\n the database handle or one of its cursors any further. Do not close\n a handle if an existing transaction has modified its database.\n Doing so can cause misbehavior from database corruption to errors\n like MDB_BAD_VALSIZE (since the DB name is gone).\n\n Closing a database handle is not necessary, but lets #mdb_dbi_open()\n reuse the handle value.  Usually it's better to set a bigger\n #mdb_env_set_maxdbs(), unless that value would be large.\n\n @param[in] env An environment handle returned by #mdb_env_create()\n @param[in] dbi A database handle returned by #mdb_dbi_open()"]
    pub fn mdb_dbi_close(env: *mut MDB_env, dbi: MDB_dbi);
}
extern "C" {
    #[doc = " @brief Empty or delete+close a database.\n\n See #mdb_dbi_close() for restrictions about closing the DB handle.\n @param[in] txn A transaction handle returned by #mdb_txn_begin()\n @param[in] dbi A database handle returned by #mdb_dbi_open()\n @param[in] del 0 to empty the DB, 1 to delete it from the\n environment and close the DB handle.\n @return A non-zero error value on failure and 0 on success."]
    pub fn mdb_drop(
        txn: *mut MDB_txn,
        dbi: MDB_dbi,
        del: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set a custom key comparison function for a database.\n\n The comparison function is called whenever it is necessary to compare a\n key specified by the application with a key currently stored in the database.\n If no comparison function is specified, and no special key flags were specified\n with #mdb_dbi_open(), the keys are compared lexically, with shorter keys collating\n before longer keys.\n @warning This function must be called before any data access functions are used,\n otherwise data corruption may occur. The same comparison function must be used by every\n program accessing the database, every time the database is used.\n @param[in] txn A transaction handle returned by #mdb_txn_begin()\n @param[in] dbi A database handle returned by #mdb_dbi_open()\n @param[in] cmp A #MDB_cmp_func function\n @return A non-zero error value on failure and 0 on success. Some possible\n errors are:\n <ul>\n\t<li>EINVAL - an invalid parameter was specified.\n </ul>"]
    pub fn mdb_set_compare(
        txn: *mut MDB_txn,
        dbi: MDB_dbi,
        cmp: MDB_cmp_func,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set a custom data comparison function for a #MDB_DUPSORT database.\n\n This comparison function is called whenever it is necessary to compare a data\n item specified by the application with a data item currently stored in the database.\n This function only takes effect if the database was opened with the #MDB_DUPSORT\n flag.\n If no comparison function is specified, and no special key flags were specified\n with #mdb_dbi_open(), the data items are compared lexically, with shorter items collating\n before longer items.\n @warning This function must be called before any data access functions are used,\n otherwise data corruption may occur. The same comparison function must be used by every\n program accessing the database, every time the database is used.\n @param[in] txn A transaction handle returned by #mdb_txn_begin()\n @param[in] dbi A database handle returned by #mdb_dbi_open()\n @param[in] cmp A #MDB_cmp_func function\n @return A non-zero error value on failure and 0 on success. Some possible\n errors are:\n <ul>\n\t<li>EINVAL - an invalid parameter was specified.\n </ul>"]
    pub fn mdb_set_dupsort(
        txn: *mut MDB_txn,
        dbi: MDB_dbi,
        cmp: MDB_cmp_func,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set a relocation function for a #MDB_FIXEDMAP database.\n\n @todo The relocation function is called whenever it is necessary to move the data\n of an item to a different position in the database (e.g. through tree\n balancing operations, shifts as a result of adds or deletes, etc.). It is\n intended to allow address/position-dependent data items to be stored in\n a database in an environment opened with the #MDB_FIXEDMAP option.\n Currently the relocation feature is unimplemented and setting\n this function has no effect.\n @param[in] txn A transaction handle returned by #mdb_txn_begin()\n @param[in] dbi A database handle returned by #mdb_dbi_open()\n @param[in] rel A #MDB_rel_func function\n @return A non-zero error value on failure and 0 on success. Some possible\n errors are:\n <ul>\n\t<li>EINVAL - an invalid parameter was specified.\n </ul>"]
    pub fn mdb_set_relfunc(
        txn: *mut MDB_txn,
        dbi: MDB_dbi,
        rel: MDB_rel_func,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Set a context pointer for a #MDB_FIXEDMAP database's relocation function.\n\n See #mdb_set_relfunc and #MDB_rel_func for more details.\n @param[in] txn A transaction handle returned by #mdb_txn_begin()\n @param[in] dbi A database handle returned by #mdb_dbi_open()\n @param[in] ctx An arbitrary pointer for whatever the application needs.\n It will be passed to the callback function set by #mdb_set_relfunc\n as its \\b relctx parameter whenever the callback is invoked.\n @return A non-zero error value on failure and 0 on success. Some possible\n errors are:\n <ul>\n\t<li>EINVAL - an invalid parameter was specified.\n </ul>"]
    pub fn mdb_set_relctx(
        txn: *mut MDB_txn,
        dbi: MDB_dbi,
        ctx: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Get items from a database.\n\n This function retrieves key/data pairs from the database. The address\n and length of the data associated with the specified \\b key are returned\n in the structure to which \\b data refers.\n If the database supports duplicate keys (#MDB_DUPSORT) then the\n first data item for the key will be returned. Retrieval of other\n items requires the use of #mdb_cursor_get().\n\n @note The memory pointed to by the returned values is owned by the\n database. The caller need not dispose of the memory, and may not\n modify it in any way. For values returned in a read-only transaction\n any modification attempts will cause a SIGSEGV.\n @note Values returned from the database are valid only until a\n subsequent update operation, or the end of the transaction.\n @param[in] txn A transaction handle returned by #mdb_txn_begin()\n @param[in] dbi A database handle returned by #mdb_dbi_open()\n @param[in] key The key to search for in the database\n @param[out] data The data corresponding to the key\n @return A non-zero error value on failure and 0 on success. Some possible\n errors are:\n <ul>\n\t<li>#MDB_NOTFOUND - the key was not in the database.\n\t<li>EINVAL - an invalid parameter was specified.\n </ul>"]
    pub fn mdb_get(
        txn: *mut MDB_txn,
        dbi: MDB_dbi,
        key: *mut MDB_val,
        data: *mut MDB_val,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Store items into a database.\n\n This function stores key/data pairs in the database. The default behavior\n is to enter the new key/data pair, replacing any previously existing key\n if duplicates are disallowed, or adding a duplicate data item if\n duplicates are allowed (#MDB_DUPSORT).\n @param[in] txn A transaction handle returned by #mdb_txn_begin()\n @param[in] dbi A database handle returned by #mdb_dbi_open()\n @param[in] key The key to store in the database\n @param[in,out] data The data to store\n @param[in] flags Special options for this operation. This parameter\n must be set to 0 or by bitwise OR'ing together one or more of the\n values described here.\n <ul>\n\t<li>#MDB_NODUPDATA - enter the new key/data pair only if it does not\n\t\talready appear in the database. This flag may only be specified\n\t\tif the database was opened with #MDB_DUPSORT. The function will\n\t\treturn #MDB_KEYEXIST if the key/data pair already appears in the\n\t\tdatabase.\n\t<li>#MDB_NOOVERWRITE - enter the new key/data pair only if the key\n\t\tdoes not already appear in the database. The function will return\n\t\t#MDB_KEYEXIST if the key already appears in the database, even if\n\t\tthe database supports duplicates (#MDB_DUPSORT). The \\b data\n\t\tparameter will be set to point to the existing item.\n\t<li>#MDB_RESERVE - reserve space for data of the given size, but\n\t\tdon't copy the given data. Instead, return a pointer to the\n\t\treserved space, which the caller can fill in later - before\n\t\tthe next update operation or the transaction ends. This saves\n\t\tan extra memcpy if the data is being generated later.\n\t\tLMDB does nothing else with this memory, the caller is expected\n\t\tto modify all of the space requested. This flag must not be\n\t\tspecified if the database was opened with #MDB_DUPSORT.\n\t<li>#MDB_APPEND - append the given key/data pair to the end of the\n\t\tdatabase. This option allows fast bulk loading when keys are\n\t\talready known to be in the correct order. Loading unsorted keys\n\t\twith this flag will cause a #MDB_KEYEXIST error.\n\t<li>#MDB_APPENDDUP - as above, but for sorted dup data.\n </ul>\n @return A non-zero error value on failure and 0 on success. Some possible\n errors are:\n <ul>\n\t<li>#MDB_MAP_FULL - the database is full, see #mdb_env_set_mapsize().\n\t<li>#MDB_TXN_FULL - the transaction has too many dirty pages.\n\t<li>EACCES - an attempt was made to write in a read-only transaction.\n\t<li>EINVAL - an invalid parameter was specified.\n </ul>"]
    pub fn mdb_put(
        txn: *mut MDB_txn,
        dbi: MDB_dbi,
        key: *mut MDB_val,
        data: *mut MDB_val,
        flags: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Delete items from a database.\n\n This function removes key/data pairs from the database.\n If the database does not support sorted duplicate data items\n (#MDB_DUPSORT) the data parameter is ignored.\n If the database supports sorted duplicates and the data parameter\n is NULL, all of the duplicate data items for the key will be\n deleted. Otherwise, if the data parameter is non-NULL\n only the matching data item will be deleted.\n This function will return #MDB_NOTFOUND if the specified key/data\n pair is not in the database.\n @param[in] txn A transaction handle returned by #mdb_txn_begin()\n @param[in] dbi A database handle returned by #mdb_dbi_open()\n @param[in] key The key to delete from the database\n @param[in] data The data to delete\n @return A non-zero error value on failure and 0 on success. Some possible\n errors are:\n <ul>\n\t<li>EACCES - an attempt was made to write in a read-only transaction.\n\t<li>EINVAL - an invalid parameter was specified.\n </ul>"]
    pub fn mdb_del(
        txn: *mut MDB_txn,
        dbi: MDB_dbi,
        key: *mut MDB_val,
        data: *mut MDB_val,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Create a cursor handle.\n\n A cursor is associated with a specific transaction and database.\n A cursor cannot be used when its database handle is closed.  Nor\n when its transaction has ended, except with #mdb_cursor_renew().\n It can be discarded with #mdb_cursor_close().\n A cursor in a write-transaction can be closed before its transaction\n ends, and will otherwise be closed when its transaction ends.\n A cursor in a read-only transaction must be closed explicitly, before\n or after its transaction ends. It can be reused with\n #mdb_cursor_renew() before finally closing it.\n @note Earlier documentation said that cursors in every transaction\n were closed when the transaction committed or aborted.\n @param[in] txn A transaction handle returned by #mdb_txn_begin()\n @param[in] dbi A database handle returned by #mdb_dbi_open()\n @param[out] cursor Address where the new #MDB_cursor handle will be stored\n @return A non-zero error value on failure and 0 on success. Some possible\n errors are:\n <ul>\n\t<li>EINVAL - an invalid parameter was specified.\n </ul>"]
    pub fn mdb_cursor_open(
        txn: *mut MDB_txn,
        dbi: MDB_dbi,
        cursor: *mut *mut MDB_cursor,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Close a cursor handle.\n\n The cursor handle will be freed and must not be used again after this call.\n Its transaction must still be live if it is a write-transaction.\n @param[in] cursor A cursor handle returned by #mdb_cursor_open()"]
    pub fn mdb_cursor_close(cursor: *mut MDB_cursor);
}
extern "C" {
    #[doc = " @brief Renew a cursor handle.\n\n A cursor is associated with a specific transaction and database.\n Cursors that are only used in read-only\n transactions may be re-used, to avoid unnecessary malloc/free overhead.\n The cursor may be associated with a new read-only transaction, and\n referencing the same database handle as it was created with.\n This may be done whether the previous transaction is live or dead.\n @param[in] txn A transaction handle returned by #mdb_txn_begin()\n @param[in] cursor A cursor handle returned by #mdb_cursor_open()\n @return A non-zero error value on failure and 0 on success. Some possible\n errors are:\n <ul>\n\t<li>EINVAL - an invalid parameter was specified.\n </ul>"]
    pub fn mdb_cursor_renew(txn: *mut MDB_txn, cursor: *mut MDB_cursor) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Return the cursor's transaction handle.\n\n @param[in] cursor A cursor handle returned by #mdb_cursor_open()"]
    pub fn mdb_cursor_txn(cursor: *mut MDB_cursor) -> *mut MDB_txn;
}
extern "C" {
    #[doc = " @brief Return the cursor's database handle.\n\n @param[in] cursor A cursor handle returned by #mdb_cursor_open()"]
    pub fn mdb_cursor_dbi(cursor: *mut MDB_cursor) -> MDB_dbi;
}
extern "C" {
    #[doc = " @brief Retrieve by cursor.\n\n This function retrieves key/data pairs from the database. The address and length\n of the key are returned in the object to which \\b key refers (except for the\n case of the #MDB_SET option, in which the \\b key object is unchanged), and\n the address and length of the data are returned in the object to which \\b data\n refers.\n See #mdb_get() for restrictions on using the output values.\n @param[in] cursor A cursor handle returned by #mdb_cursor_open()\n @param[in,out] key The key for a retrieved item\n @param[in,out] data The data of a retrieved item\n @param[in] op A cursor operation #MDB_cursor_op\n @return A non-zero error value on failure and 0 on success. Some possible\n errors are:\n <ul>\n\t<li>#MDB_NOTFOUND - no matching key found.\n\t<li>EINVAL - an invalid parameter was specified.\n </ul>"]
    pub fn mdb_cursor_get(
        cursor: *mut MDB_cursor,
        key: *mut MDB_val,
        data: *mut MDB_val,
        op: MDB_cursor_op,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Store by cursor.\n\n This function stores key/data pairs into the database.\n The cursor is positioned at the new item, or on failure usually near it.\n @note Earlier documentation incorrectly said errors would leave the\n state of the cursor unchanged.\n @param[in] cursor A cursor handle returned by #mdb_cursor_open()\n @param[in] key The key operated on.\n @param[in] data The data operated on.\n @param[in] flags Options for this operation. This parameter\n must be set to 0 or one of the values described here.\n <ul>\n\t<li>#MDB_CURRENT - replace the item at the current cursor position.\n\t\tThe \\b key parameter must still be provided, and must match it.\n\t\tIf using sorted duplicates (#MDB_DUPSORT) the data item must still\n\t\tsort into the same place. This is intended to be used when the\n\t\tnew data is the same size as the old. Otherwise it will simply\n\t\tperform a delete of the old record followed by an insert.\n\t<li>#MDB_NODUPDATA - enter the new key/data pair only if it does not\n\t\talready appear in the database. This flag may only be specified\n\t\tif the database was opened with #MDB_DUPSORT. The function will\n\t\treturn #MDB_KEYEXIST if the key/data pair already appears in the\n\t\tdatabase.\n\t<li>#MDB_NOOVERWRITE - enter the new key/data pair only if the key\n\t\tdoes not already appear in the database. The function will return\n\t\t#MDB_KEYEXIST if the key already appears in the database, even if\n\t\tthe database supports duplicates (#MDB_DUPSORT).\n\t<li>#MDB_RESERVE - reserve space for data of the given size, but\n\t\tdon't copy the given data. Instead, return a pointer to the\n\t\treserved space, which the caller can fill in later - before\n\t\tthe next update operation or the transaction ends. This saves\n\t\tan extra memcpy if the data is being generated later. This flag\n\t\tmust not be specified if the database was opened with #MDB_DUPSORT.\n\t<li>#MDB_APPEND - append the given key/data pair to the end of the\n\t\tdatabase. No key comparisons are performed. This option allows\n\t\tfast bulk loading when keys are already known to be in the\n\t\tcorrect order. Loading unsorted keys with this flag will cause\n\t\ta #MDB_KEYEXIST error.\n\t<li>#MDB_APPENDDUP - as above, but for sorted dup data.\n\t<li>#MDB_MULTIPLE - store multiple contiguous data elements in a\n\t\tsingle request. This flag may only be specified if the database\n\t\twas opened with #MDB_DUPFIXED. The \\b data argument must be an\n\t\tarray of two MDB_vals. The mv_size of the first MDB_val must be\n\t\tthe size of a single data element. The mv_data of the first MDB_val\n\t\tmust point to the beginning of the array of contiguous data elements.\n\t\tThe mv_size of the second MDB_val must be the count of the number\n\t\tof data elements to store. On return this field will be set to\n\t\tthe count of the number of elements actually written. The mv_data\n\t\tof the second MDB_val is unused.\n </ul>\n @return A non-zero error value on failure and 0 on success. Some possible\n errors are:\n <ul>\n\t<li>#MDB_MAP_FULL - the database is full, see #mdb_env_set_mapsize().\n\t<li>#MDB_TXN_FULL - the transaction has too many dirty pages.\n\t<li>EACCES - an attempt was made to write in a read-only transaction.\n\t<li>EINVAL - an invalid parameter was specified.\n </ul>"]
    pub fn mdb_cursor_put(
        cursor: *mut MDB_cursor,
        key: *mut MDB_val,
        data: *mut MDB_val,
        flags: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Delete current key/data pair\n\n This function deletes the key/data pair to which the cursor refers.\n This does not invalidate the cursor, so operations such as MDB_NEXT\n can still be used on it.\n Both MDB_NEXT and MDB_GET_CURRENT will return the same record after\n this operation.\n @param[in] cursor A cursor handle returned by #mdb_cursor_open()\n @param[in] flags Options for this operation. This parameter\n must be set to 0 or one of the values described here.\n <ul>\n\t<li>#MDB_NODUPDATA - delete all of the data items for the current key.\n\t\tThis flag may only be specified if the database was opened with #MDB_DUPSORT.\n </ul>\n @return A non-zero error value on failure and 0 on success. Some possible\n errors are:\n <ul>\n\t<li>EACCES - an attempt was made to write in a read-only transaction.\n\t<li>EINVAL - an invalid parameter was specified.\n </ul>"]
    pub fn mdb_cursor_del(
        cursor: *mut MDB_cursor,
        flags: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Return count of duplicates for current key.\n\n This call is only valid on databases that support sorted duplicate\n data items #MDB_DUPSORT.\n @param[in] cursor A cursor handle returned by #mdb_cursor_open()\n @param[out] countp Address where the count will be stored\n @return A non-zero error value on failure and 0 on success. Some possible\n errors are:\n <ul>\n\t<li>EINVAL - cursor is not initialized, or an invalid parameter was specified.\n </ul>"]
    pub fn mdb_cursor_count(
        cursor: *mut MDB_cursor,
        countp: *mut mdb_size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Compare two data items according to a particular database.\n\n This returns a comparison as if the two data items were keys in the\n specified database.\n @param[in] txn A transaction handle returned by #mdb_txn_begin()\n @param[in] dbi A database handle returned by #mdb_dbi_open()\n @param[in] a The first item to compare\n @param[in] b The second item to compare\n @return < 0 if a < b, 0 if a == b, > 0 if a > b"]
    pub fn mdb_cmp(
        txn: *mut MDB_txn,
        dbi: MDB_dbi,
        a: *const MDB_val,
        b: *const MDB_val,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Compare two data items according to a particular database.\n\n This returns a comparison as if the two items were data items of\n the specified database. The database must have the #MDB_DUPSORT flag.\n @param[in] txn A transaction handle returned by #mdb_txn_begin()\n @param[in] dbi A database handle returned by #mdb_dbi_open()\n @param[in] a The first item to compare\n @param[in] b The second item to compare\n @return < 0 if a < b, 0 if a == b, > 0 if a > b"]
    pub fn mdb_dcmp(
        txn: *mut MDB_txn,
        dbi: MDB_dbi,
        a: *const MDB_val,
        b: *const MDB_val,
    ) -> ::std::os::raw::c_int;
}
#[doc = " @brief A callback function used to print a message from the library.\n\n @param[in] msg The string to be printed.\n @param[in] ctx An arbitrary context pointer for the callback.\n @return < 0 on failure, >= 0 on success."]
pub type MDB_msg_func = ::std::option::Option<
    unsafe extern "C" fn(
        msg: *const ::std::os::raw::c_char,
        ctx: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    #[doc = " @brief Dump the entries in the reader lock table.\n\n @param[in] env An environment handle returned by #mdb_env_create()\n @param[in] func A #MDB_msg_func function\n @param[in] ctx Anything the message function needs\n @return < 0 on failure, >= 0 on success."]
    pub fn mdb_reader_list(
        env: *mut MDB_env,
        func: MDB_msg_func,
        ctx: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Check for stale entries in the reader lock table.\n\n @param[in] env An environment handle returned by #mdb_env_create()\n @param[out] dead Number of stale slots that were cleared\n @return 0 on success, non-zero on failure."]
    pub fn mdb_reader_check(
        env: *mut MDB_env,
        dead: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
pub type __builtin_va_list = *mut ::std::os::raw::c_char;
